// 
// ******************************************************************************
// *                                                                            *
// *                   Copyright (C) 2004-2016, Nangate Inc.                    *
// *                           All rights reserved.                             *
// *                                                                            *
// * Nangate and the Nangate logo are trademarks of Nangate Inc.                *
// *                                                                            *
// * All trademarks, logos, software marks, and trade names (collectively the   *
// * "Marks") in this program are proprietary to Nangate or other respective    *
// * owners that have granted Nangate the right and license to use such Marks.  *
// * You are not permitted to use the Marks without the prior written consent   *
// * of Nangate or such third party that may own the Marks.                     *
// *                                                                            *
// * This file has been provided pursuant to a License Agreement containing     *
// * restrictions on its use. This file contains valuable trade secrets and     *
// * proprietary information of Nangate Inc., and is protected by U.S. and      *
// * international laws and/or treaties.                                        *
// *                                                                            *
// * The copyright notice(s) in this file does not indicate actual or intended  *
// * publication of this file.                                                  *
// *                                                                            *
// *     NGLibraryCharacterizer, v2015.06-QR03-SP2_64 - build 201511122113      *
// *                                                                            *
// ******************************************************************************
// 
// 
// Running on wup35822 for user Kaufmann Bodo (bka).
// Local time is now Wed, 22 Jun 2016, 08:54:35.
// Main process id is 2564.
// 
// * Default delays
//   * comb. path delay        : 0.0
//   * seq. path delay         : 0.0
//   * delay cells             : 0.0
//   * timing checks           : 0.0
// 
// * NTC Setup
//   * Export NTC sections     : true
//   * Combine setup / hold    : true
//   * Combine recovery/removal: true
// 
// * Extras
//   * Export `celldefine      : false
//   * Export `timescale       : -
// 

`timescale 1ns/1ps
`celldefine

`define NTC
`define RECREM


module AND2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_112, C);
  and(i_112, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_91, C);
  and(i_91, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_214, C);
  and(i_214, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_40, C);
  and(i_40, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_28, C);
  and(i_28, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_64, C);
  and(i_64, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module ANTENNA_HV (A);
  input A;

endmodule

module ANTENNAP_HV (A);
  input A;

endmodule

module ANTENNAN_HV (A);
  input A;

endmodule

module AOI21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_86);
  or(i_86, i_87, B1);
  and(i_87, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_98);
  or(i_98, i_99, B1);
  and(i_99, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_128);
  or(i_128, i_129, B1);
  and(i_129, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_74);
  or(i_74, i_75, B1);
  and(i_75, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_74);
  or(i_74, i_75, B1);
  and(i_75, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_98);
  or(i_98, i_99, B1);
  and(i_99, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_183);
  or(i_183, i_184, i_185);
  and(i_184, A1, A2);
  and(i_185, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_138);
  or(i_138, i_139, i_140);
  and(i_139, A1, A2);
  and(i_140, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_78);
  or(i_78, i_79, i_80);
  and(i_79, A1, A2);
  and(i_80, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_225);
  or(i_225, i_226, i_227);
  and(i_226, A1, A2);
  and(i_227, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_84);
  or(i_84, i_85, i_86);
  and(i_85, A1, A2);
  and(i_86, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_150);
  or(i_150, i_151, i_152);
  and(i_151, A1, A2);
  and(i_152, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_66);
  or(i_66, i_67, B1);
  and(i_67, i_68, A3);
  and(i_68, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_162);
  or(i_162, i_163, B1);
  and(i_163, i_164, A3);
  and(i_164, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_48);
  or(i_48, i_49, B1);
  and(i_49, i_50, A3);
  and(i_50, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_30);
  or(i_30, i_31, B1);
  and(i_31, i_32, A3);
  and(i_32, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_120);
  or(i_120, i_121, B1);
  and(i_121, i_122, A3);
  and(i_122, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_84);
  or(i_84, i_85, B1);
  and(i_85, i_86, A3);
  and(i_86, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_34);
  or(i_34, i_35, i_37);
  and(i_35, i_36, A3);
  and(i_36, A1, A2);
  and(i_37, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_16);
  or(i_16, i_17, i_19);
  and(i_17, i_18, A3);
  and(i_18, A1, A2);
  and(i_19, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_88);
  or(i_88, i_89, i_91);
  and(i_89, i_90, A3);
  and(i_90, A1, A2);
  and(i_91, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_112);
  or(i_112, i_113, i_115);
  and(i_113, i_114, A3);
  and(i_114, A1, A2);
  and(i_115, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_34);
  or(i_34, i_35, i_37);
  and(i_35, i_36, A3);
  and(i_36, A1, A2);
  and(i_37, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_88);
  or(i_88, i_89, i_91);
  and(i_89, i_90, A3);
  and(i_90, A1, A2);
  and(i_91, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_147);
  or(i_147, i_148, C1);
  or(i_148, i_149, B1);
  and(i_149, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_165);
  or(i_165, i_166, C1);
  or(i_166, i_167, B1);
  and(i_167, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_54);
  or(i_54, i_55, C1);
  or(i_55, i_56, B1);
  and(i_56, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_78);
  or(i_78, i_79, C1);
  or(i_79, i_80, B1);
  and(i_80, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_66);
  or(i_66, i_67, C1);
  or(i_67, i_68, B1);
  and(i_68, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_78);
  or(i_78, i_79, C1);
  or(i_79, i_80, B1);
  and(i_80, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_115);
  or(i_115, i_116, C1);
  or(i_116, i_117, i_118);
  and(i_117, A1, A2);
  and(i_118, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_49);
  or(i_49, i_50, C1);
  or(i_50, i_51, i_52);
  and(i_51, A1, A2);
  and(i_52, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_34);
  or(i_34, i_35, C1);
  or(i_35, i_36, i_37);
  and(i_36, A1, A2);
  and(i_37, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_34);
  or(i_34, i_35, C1);
  or(i_35, i_36, i_37);
  and(i_36, A1, A2);
  and(i_37, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_16);
  or(i_16, i_17, C1);
  or(i_17, i_18, i_19);
  and(i_18, A1, A2);
  and(i_19, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_145);
  or(i_145, i_146, C1);
  or(i_146, i_147, i_148);
  and(i_147, A1, A2);
  and(i_148, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X1_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_130);
  or(i_130, i_131, C1);
  or(i_131, i_132, B1);
  and(i_132, i_133, A3);
  and(i_133, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X2_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_40);
  or(i_40, i_41, C1);
  or(i_41, i_42, B1);
  and(i_42, i_43, A3);
  and(i_43, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X3_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_34);
  or(i_34, i_35, C1);
  or(i_35, i_36, B1);
  and(i_36, i_37, A3);
  and(i_37, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X4_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_16);
  or(i_16, i_17, C1);
  or(i_17, i_18, B1);
  and(i_18, i_19, A3);
  and(i_19, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X6_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_70);
  or(i_70, i_71, C1);
  or(i_71, i_72, B1);
  and(i_72, i_73, A3);
  and(i_73, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X8_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_133);
  or(i_133, i_134, C1);
  or(i_134, i_135, B1);
  and(i_135, i_136, A3);
  and(i_136, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_274, B1);
  and(i_274, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_4, B1);
  and(i_4, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_88, B1);
  and(i_88, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_250, B1);
  and(i_250, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_64, B1);
  and(i_64, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_58, B1);
  and(i_58, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_38, i_39);
  and(i_38, A1, A2);
  and(i_39, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_104, i_105);
  and(i_104, A1, A2);
  and(i_105, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_122, i_123);
  and(i_122, A1, A2);
  and(i_123, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_176, i_177);
  and(i_176, A1, A2);
  and(i_177, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_122, i_123);
  and(i_122, A1, A2);
  and(i_123, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_122, i_123);
  and(i_122, A1, A2);
  and(i_123, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_101, B1);
  and(i_101, i_102, A3);
  and(i_102, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_8, B1);
  and(i_8, i_9, A3);
  and(i_9, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_128, B1);
  and(i_128, i_129, A3);
  and(i_129, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_110, B1);
  and(i_110, i_111, A3);
  and(i_111, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_149, B1);
  and(i_149, i_150, A3);
  and(i_150, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_167, B1);
  and(i_167, i_168, A3);
  and(i_168, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_96, i_98);
  and(i_96, i_97, A3);
  and(i_97, A1, A2);
  and(i_98, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_132, i_134);
  and(i_132, i_133, A3);
  and(i_133, A1, A2);
  and(i_134, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_12, i_14);
  and(i_12, i_13, A3);
  and(i_13, A1, A2);
  and(i_14, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_96, i_98);
  and(i_96, i_97, A3);
  and(i_97, A1, A2);
  and(i_98, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_12, i_14);
  and(i_12, i_13, A3);
  and(i_13, A1, A2);
  and(i_14, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_108, i_110);
  and(i_108, i_109, A3);
  and(i_109, A1, A2);
  and(i_110, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_44, C1);
  or(i_44, i_45, B1);
  and(i_45, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_50, C1);
  or(i_50, i_51, B1);
  and(i_51, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_74, C1);
  or(i_74, i_75, B1);
  and(i_75, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_50, C1);
  or(i_50, i_51, B1);
  and(i_51, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_26, C1);
  or(i_26, i_27, B1);
  and(i_27, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_44, C1);
  or(i_44, i_45, B1);
  and(i_45, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_12, C1);
  or(i_12, i_13, i_14);
  and(i_13, A1, A2);
  and(i_14, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_12, C1);
  or(i_12, i_13, i_14);
  and(i_13, A1, A2);
  and(i_14, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_96, C1);
  or(i_96, i_97, i_98);
  and(i_97, A1, A2);
  and(i_98, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_12, C1);
  or(i_12, i_13, i_14);
  and(i_13, A1, A2);
  and(i_14, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_102, C1);
  or(i_102, i_103, i_104);
  and(i_103, A1, A2);
  and(i_104, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_114, C1);
  or(i_114, i_115, i_116);
  and(i_115, A1, A2);
  and(i_116, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFEX2_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFEX4_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFEX6_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFEX8_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFEX10_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFEX12_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFEX16_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFTX2_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFTX4_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFTX6_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFTX8_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFTX10_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFTX12_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFTX16_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.1, 0.1, 0.1, 0.1, 0.1, 0.1);
  endspecify

endmodule

module BUFX2_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX3_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX4_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX6_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX8_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX12_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX16_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX24_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX32_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUSHDX1_HV (A);
  inout A;

  buf(A, A);
endmodule

module CLKBUFX2_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX3_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX4_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX6_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX8_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX10_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX12_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX16_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX24_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX32_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX1_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX2_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX3_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX4_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX6_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX8_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX10_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX12_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX16_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX24_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX32_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

primitive \seq_DFCPSX1_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX1_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX1_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_44, i_45);
    not(i_44, IQ);
    not(i_45, i_46);
    and(i_46, i_47, i_48);
    not(i_47, SN_d);
    not(i_48, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_49, i_50);
    and(i_49, SE_d, SI_d);
    and(i_50, i_51, D_d);
    not(i_51, SE_d);

    // Delayed data/reference logic
    and(id_39, SN_d, RN_d);
    and(id_40, id_39, i_56);
    not(i_56, SE_d);
    and(id_41, id_39, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_39, id_39, 1'b1);
      ng_xbuf(xid_40, id_40, 1'b1);
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    \seq_DFCPSX1_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_44, i_45);
    not(i_44, IQ);
    not(i_45, i_46);
    and(i_46, i_47, i_48);
    not(i_47, SN);
    not(i_48, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_49, i_50);
    and(i_49, SE, SI);
    and(i_50, i_51, D);
    not(i_51, SE);

    // Delayed data/reference logic
    and(id_36, SN, RN);
    and(id_37, id_36, i_55);
    not(i_55, SE);
    and(id_38, id_36, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_36, id_36, 1'b1);
      ng_xbuf(xid_37, id_37, 1'b1);
      ng_xbuf(xid_38, id_38, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_41), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_41), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX2_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX2_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX2_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN_d);
    not(i_30, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE_d, SI_d);
    and(i_32, i_33, D_d);
    not(i_33, SE_d);

    // Delayed data/reference logic
    and(id_15, SN_d, RN_d);
    and(id_16, id_15, i_38);
    not(i_38, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFCPSX2_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN);
    not(i_30, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE, SI);
    and(i_32, i_33, D);
    not(i_33, SE);

    // Delayed data/reference logic
    and(id_12, SN, RN);
    and(id_13, id_12, i_37);
    not(i_37, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX3_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX3_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX3_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN_d);
    not(i_30, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE_d, SI_d);
    and(i_32, i_33, D_d);
    not(i_33, SE_d);

    // Delayed data/reference logic
    and(id_21, SN_d, RN_d);
    and(id_22, id_21, i_38);
    not(i_38, SE_d);
    and(id_23, id_21, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_21, id_21, 1'b1);
      ng_xbuf(xid_22, id_22, 1'b1);
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_DFCPSX3_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN);
    not(i_30, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE, SI);
    and(i_32, i_33, D);
    not(i_33, SE);

    // Delayed data/reference logic
    and(id_18, SN, RN);
    and(id_19, id_18, i_37);
    not(i_37, SE);
    and(id_20, id_18, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_18, id_18, 1'b1);
      ng_xbuf(xid_19, id_19, 1'b1);
      ng_xbuf(xid_20, id_20, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_23), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX4_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX4_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX4_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_44, i_45);
    not(i_44, IQ);
    not(i_45, i_46);
    and(i_46, i_47, i_48);
    not(i_47, SN_d);
    not(i_48, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_49, i_50);
    and(i_49, SE_d, SI_d);
    and(i_50, i_51, D_d);
    not(i_51, SE_d);

    // Delayed data/reference logic
    and(id_45, SN_d, RN_d);
    and(id_46, id_45, i_56);
    not(i_56, SE_d);
    and(id_47, id_45, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_45, id_45, 1'b1);
      ng_xbuf(xid_46, id_46, 1'b1);
      ng_xbuf(xid_47, id_47, 1'b1);
    `endif
  `else
    \seq_DFCPSX4_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_44, i_45);
    not(i_44, IQ);
    not(i_45, i_46);
    and(i_46, i_47, i_48);
    not(i_47, SN);
    not(i_48, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_49, i_50);
    and(i_49, SE, SI);
    and(i_50, i_51, D);
    not(i_51, SE);

    // Delayed data/reference logic
    and(id_42, SN, RN);
    and(id_43, id_42, i_55);
    not(i_55, SE);
    and(id_44, id_42, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_42, id_42, 1'b1);
      ng_xbuf(xid_43, id_43, 1'b1);
      ng_xbuf(xid_44, id_44, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_46), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_46), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_47), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_47), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX6_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX6_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX6_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN_d);
    not(i_30, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE_d, SI_d);
    and(i_32, i_33, D_d);
    not(i_33, SE_d);

    // Delayed data/reference logic
    and(id_15, SN_d, RN_d);
    and(id_16, id_15, i_38);
    not(i_38, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFCPSX6_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN);
    not(i_30, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE, SI);
    and(i_32, i_33, D);
    not(i_33, SE);

    // Delayed data/reference logic
    and(id_12, SN, RN);
    and(id_13, id_12, i_37);
    not(i_37, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX1_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX1_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX1_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN_d);
    not(i_14, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_11, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFCPX1_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN);
    not(i_14, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_10, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX2_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX2_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX2_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_28, i_29);
    not(i_28, IQ);
    not(i_29, i_30);
    and(i_30, i_31, i_32);
    not(i_31, SN_d);
    not(i_32, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFCPX2_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_28, i_29);
    not(i_28, IQ);
    not(i_29, i_30);
    and(i_30, i_31, i_32);
    not(i_31, SN);
    not(i_32, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX3_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX3_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX3_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_94, i_95);
    not(i_94, IQ);
    not(i_95, i_96);
    and(i_96, i_97, i_98);
    not(i_97, SN_d);
    not(i_98, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_59, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_59, id_59, 1'b1);
    `endif
  `else
    \seq_DFCPX3_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_94, i_95);
    not(i_94, IQ);
    not(i_95, i_96);
    and(i_96, i_97, i_98);
    not(i_97, SN);
    not(i_98, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_58, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_58, id_58, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_59), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_59), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_59), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_59), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_58), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_58), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_58), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_58), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX4_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX4_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX4_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_91, i_92);
    not(i_91, IQ);
    not(i_92, i_93);
    and(i_93, i_94, i_95);
    not(i_94, SN_d);
    not(i_95, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_71, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_71, id_71, 1'b1);
    `endif
  `else
    \seq_DFCPX4_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_91, i_92);
    not(i_91, IQ);
    not(i_92, i_93);
    and(i_93, i_94, i_95);
    not(i_94, SN);
    not(i_95, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_70, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_70, id_70, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_71), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_71), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_71), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_71), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_70), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_70), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_70), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_70), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX6_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX6_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX6_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN_d);
    not(i_14, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFCPX6_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN);
    not(i_14, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX1_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX1_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX1_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE_d, SI_d);
    and(i_41, i_42, D_d);
    not(i_42, SE_d);

    // Delayed data/reference logic
    buf(id_39, RN_d);
    and(id_40, id_39, i_47);
    not(i_47, SE_d);
    and(id_41, id_39, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_39, id_39, 1'b1);
      ng_xbuf(xid_40, id_40, 1'b1);
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    \seq_DFCSX1_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE, SI);
    and(i_41, i_42, D);
    not(i_42, SE);

    // Delayed data/reference logic
    buf(id_36, RN);
    and(id_37, id_36, i_46);
    not(i_46, SE);
    and(id_38, id_36, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_36, id_36, 1'b1);
      ng_xbuf(xid_37, id_37, 1'b1);
      ng_xbuf(xid_38, id_38, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_41), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_41), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX2_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX2_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX2_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_73, i_74);
    and(i_73, SE_d, SI_d);
    and(i_74, i_75, D_d);
    not(i_75, SE_d);

    // Delayed data/reference logic
    buf(id_63, RN_d);
    and(id_64, id_63, i_80);
    not(i_80, SE_d);
    and(id_65, id_63, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_63, id_63, 1'b1);
      ng_xbuf(xid_64, id_64, 1'b1);
      ng_xbuf(xid_65, id_65, 1'b1);
    `endif
  `else
    \seq_DFCSX2_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_73, i_74);
    and(i_73, SE, SI);
    and(i_74, i_75, D);
    not(i_75, SE);

    // Delayed data/reference logic
    buf(id_60, RN);
    and(id_61, id_60, i_79);
    not(i_79, SE);
    and(id_62, id_60, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_60, id_60, 1'b1);
      ng_xbuf(xid_61, id_61, 1'b1);
      ng_xbuf(xid_62, id_62, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_64), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_64), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_65), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_65), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_63), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_63), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_61), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_61), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_62), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_62), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_60), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_60), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX3_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX3_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX3_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_73, i_74);
    and(i_73, SE_d, SI_d);
    and(i_74, i_75, D_d);
    not(i_75, SE_d);

    // Delayed data/reference logic
    buf(id_57, RN_d);
    and(id_58, id_57, i_80);
    not(i_80, SE_d);
    and(id_59, id_57, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_57, id_57, 1'b1);
      ng_xbuf(xid_58, id_58, 1'b1);
      ng_xbuf(xid_59, id_59, 1'b1);
    `endif
  `else
    \seq_DFCSX3_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_73, i_74);
    and(i_73, SE, SI);
    and(i_74, i_75, D);
    not(i_75, SE);

    // Delayed data/reference logic
    buf(id_54, RN);
    and(id_55, id_54, i_79);
    not(i_79, SE);
    and(id_56, id_54, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_54, id_54, 1'b1);
      ng_xbuf(xid_55, id_55, 1'b1);
      ng_xbuf(xid_56, id_56, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_58), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_58), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_59), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_59), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_57), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_57), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_55), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_55), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_56), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_56), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_54), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_54), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX4_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX4_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX4_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE_d, SI_d);
    and(i_41, i_42, D_d);
    not(i_42, SE_d);

    // Delayed data/reference logic
    buf(id_33, RN_d);
    and(id_34, id_33, i_47);
    not(i_47, SE_d);
    and(id_35, id_33, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_33, id_33, 1'b1);
      ng_xbuf(xid_34, id_34, 1'b1);
      ng_xbuf(xid_35, id_35, 1'b1);
    `endif
  `else
    \seq_DFCSX4_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE, SI);
    and(i_41, i_42, D);
    not(i_42, SE);

    // Delayed data/reference logic
    buf(id_30, RN);
    and(id_31, id_30, i_46);
    not(i_46, SE);
    and(id_32, id_30, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_30, id_30, 1'b1);
      ng_xbuf(xid_31, id_31, 1'b1);
      ng_xbuf(xid_32, id_32, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_34), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_34), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_35), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_35), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX6_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX6_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX6_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, RN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFCSX6_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, RN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX1_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX1_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX1_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFCX1_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX2_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX2_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX2_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFCX2_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX3_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX3_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX3_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFCX3_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX4_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX4_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX4_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFCX4_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX6_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX6_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX6_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFCX6_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX1_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX1_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX1_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFPSX1_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX2_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX2_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX2_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFPSX2_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX3_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX3_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX3_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFPSX3_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX4_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX4_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX4_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE_d, SI_d);
    and(i_41, i_42, D_d);
    not(i_42, SE_d);

    // Delayed data/reference logic
    buf(id_33, SN_d);
    and(id_34, id_33, i_47);
    not(i_47, SE_d);
    and(id_35, id_33, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_33, id_33, 1'b1);
      ng_xbuf(xid_34, id_34, 1'b1);
      ng_xbuf(xid_35, id_35, 1'b1);
    `endif
  `else
    \seq_DFPSX4_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE, SI);
    and(i_41, i_42, D);
    not(i_42, SE);

    // Delayed data/reference logic
    buf(id_30, SN);
    and(id_31, id_30, i_46);
    not(i_46, SE);
    and(id_32, id_30, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_30, id_30, 1'b1);
      ng_xbuf(xid_31, id_31, 1'b1);
      ng_xbuf(xid_32, id_32, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_34), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_34), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_35), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_35), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX6_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX6_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX6_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFPSX6_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX1_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX1_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX1_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFPX1_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX2_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX2_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX2_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_DFPX2_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX3_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX3_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX3_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFPX3_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX4_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX4_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX4_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_53, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_53, id_53, 1'b1);
    `endif
  `else
    \seq_DFPX4_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_52, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_52, id_52, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_53), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_53), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_52), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_52), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX6_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX6_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX6_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFPX6_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX1_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX1_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX1_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_60, i_61);
    and(i_60, SE_d, SI_d);
    and(i_61, i_62, D_d);
    not(i_62, SE_d);

    // Delayed data/reference logic
    not(id_46, SE_d);
    buf(id_47, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_46, id_46, 1'b1);
      ng_xbuf(xid_47, id_47, 1'b1);
    `endif
  `else
    \seq_DFSX1_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_60, i_61);
    and(i_60, SE, SI);
    and(i_61, i_62, D);
    not(i_62, SE);

    // Delayed data/reference logic
    not(id_44, SE);
    buf(id_45, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_44, id_44, 1'b1);
      ng_xbuf(xid_45, id_45, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_46), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_46), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_47), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_47), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_44), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_45), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_45), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX2_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX2_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX2_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFSX2_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX3_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX3_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX3_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFSX3_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX4_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX4_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX4_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFSX4_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX6_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX6_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX6_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFSX6_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFXL_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFXL_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFXL_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFXL_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX1_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX1_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX1_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX1_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX2_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX2_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX2_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX2_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX3_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX3_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX3_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX3_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX4_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX4_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX4_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX4_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX6_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX6_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX6_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX6_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

module DLY1X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY2X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY3X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY4X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module FAX1_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_216, i_219);
  or(i_216, i_217, i_218);
  and(i_217, A, B);
  and(i_218, A, CI);
  and(i_219, B, CI);
  not(SUM, i_224);
  or(i_224, i_225, i_231);
  and(i_225, i_226, CI);
  not(i_226, i_227);
  or(i_227, i_228, i_229);
  and(i_228, A, B);
  not(i_229, i_230);
  or(i_230, A, B);
  not(i_231, i_232);
  or(i_232, i_233, CI);
  not(i_233, i_234);
  or(i_234, i_235, i_236);
  and(i_235, A, B);
  not(i_236, i_237);
  or(i_237, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX2_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_72, i_75);
  or(i_72, i_73, i_74);
  and(i_73, A, B);
  and(i_74, A, CI);
  and(i_75, B, CI);
  not(SUM, i_80);
  or(i_80, i_81, i_87);
  and(i_81, i_82, CI);
  not(i_82, i_83);
  or(i_83, i_84, i_85);
  and(i_84, A, B);
  not(i_85, i_86);
  or(i_86, A, B);
  not(i_87, i_88);
  or(i_88, i_89, CI);
  not(i_89, i_90);
  or(i_90, i_91, i_92);
  and(i_91, A, B);
  not(i_92, i_93);
  or(i_93, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX3_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_273, i_276);
  or(i_273, i_274, i_275);
  and(i_274, A, B);
  and(i_275, A, CI);
  and(i_276, B, CI);
  not(SUM, i_281);
  or(i_281, i_282, i_288);
  and(i_282, i_283, CI);
  not(i_283, i_284);
  or(i_284, i_285, i_286);
  and(i_285, A, B);
  not(i_286, i_287);
  or(i_287, A, B);
  not(i_288, i_289);
  or(i_289, i_290, CI);
  not(i_290, i_291);
  or(i_291, i_292, i_293);
  and(i_292, A, B);
  not(i_293, i_294);
  or(i_294, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX4_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_120, i_123);
  or(i_120, i_121, i_122);
  and(i_121, A, B);
  and(i_122, A, CI);
  and(i_123, B, CI);
  not(SUM, i_128);
  or(i_128, i_129, i_135);
  and(i_129, i_130, CI);
  not(i_130, i_131);
  or(i_131, i_132, i_133);
  and(i_132, A, B);
  not(i_133, i_134);
  or(i_134, A, B);
  not(i_135, i_136);
  or(i_136, i_137, CI);
  not(i_137, i_138);
  or(i_138, i_139, i_140);
  and(i_139, A, B);
  not(i_140, i_141);
  or(i_141, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX6_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_102, i_105);
  or(i_102, i_103, i_104);
  and(i_103, A, B);
  and(i_104, A, CI);
  and(i_105, B, CI);
  not(SUM, i_110);
  or(i_110, i_111, i_117);
  and(i_111, i_112, CI);
  not(i_112, i_113);
  or(i_113, i_114, i_115);
  and(i_114, A, B);
  not(i_115, i_116);
  or(i_116, A, B);
  not(i_117, i_118);
  or(i_118, i_119, CI);
  not(i_119, i_120);
  or(i_120, i_121, i_122);
  and(i_121, A, B);
  not(i_122, i_123);
  or(i_123, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX8_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_126, i_129);
  or(i_126, i_127, i_128);
  and(i_127, A, B);
  and(i_128, A, CI);
  and(i_129, B, CI);
  not(SUM, i_134);
  or(i_134, i_135, i_141);
  and(i_135, i_136, CI);
  not(i_136, i_137);
  or(i_137, i_138, i_139);
  and(i_138, A, B);
  not(i_139, i_140);
  or(i_140, A, B);
  not(i_141, i_142);
  or(i_142, i_143, CI);
  not(i_143, i_144);
  or(i_144, i_145, i_146);
  and(i_145, A, B);
  not(i_146, i_147);
  or(i_147, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FILLCAPX4_HV ();

endmodule

module FILLCAPX8_HV ();

endmodule

module FILLCAPX16_HV ();

endmodule

module FILLCAPX32_HV ();

endmodule


module FILLCELLTDPW_HV ();

endmodule


module FILLCELLX1_HV ();

endmodule


module FILLCELLX16_HV ();

endmodule


module FILLCELLX2_HV ();

endmodule


module FILLCELLX32_HV ();

endmodule


module FILLCELLX4_HV ();

endmodule


module FILLCELLX8_HV ();

endmodule



module HAX1_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_22);
  or(i_22, i_23, i_24);
  and(i_23, A, B);
  not(i_24, i_25);
  or(i_25, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX2_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_130);
  or(i_130, i_131, i_132);
  and(i_131, A, B);
  not(i_132, i_133);
  or(i_133, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX3_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_40);
  or(i_40, i_41, i_42);
  and(i_41, A, B);
  not(i_42, i_43);
  or(i_43, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX4_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_130);
  or(i_130, i_131, i_132);
  and(i_131, A, B);
  not(i_132, i_133);
  or(i_133, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX6_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_160);
  or(i_160, i_161, i_162);
  and(i_161, A, B);
  not(i_162, i_163);
  or(i_163, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_110);
  or(i_110, i_111, i_114);
  or(i_111, i_112, i_113);
  and(i_112, B, A);
  and(i_113, C, B);
  and(i_114, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_56);
  or(i_56, i_57, i_60);
  or(i_57, i_58, i_59);
  and(i_58, B, A);
  and(i_59, C, B);
  and(i_60, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_38);
  or(i_38, i_39, i_42);
  or(i_39, i_40, i_41);
  and(i_40, B, A);
  and(i_41, C, B);
  and(i_42, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_182);
  or(i_182, i_183, i_186);
  or(i_183, i_184, i_185);
  and(i_184, B, A);
  and(i_185, C, B);
  and(i_186, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2XL_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_169);
  or(i_169, i_170, i_172);
  and(i_170, A, i_171);
  not(i_171, S);
  and(i_172, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X1_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_40);
  or(i_40, i_41, i_43);
  and(i_41, A, i_42);
  not(i_42, S);
  and(i_43, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X2_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_136);
  or(i_136, i_137, i_139);
  and(i_137, A, i_138);
  not(i_138, S);
  and(i_139, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X3_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_187);
  or(i_187, i_188, i_190);
  and(i_188, A, i_189);
  not(i_189, S);
  and(i_190, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X4_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_82);
  or(i_82, i_83, i_85);
  and(i_83, A, i_84);
  not(i_84, S);
  and(i_85, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X6_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_76);
  or(i_76, i_77, i_79);
  and(i_77, A, i_78);
  not(i_78, S);
  and(i_79, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X8_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_46);
  or(i_46, i_47, i_49);
  and(i_47, A, i_48);
  not(i_48, S);
  and(i_49, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X1_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_64);
  or(i_64, i_65, i_73);
  or(i_65, i_66, i_70);
  and(i_66, i_67, i_69);
  and(i_67, A, i_68);
  not(i_68, S1);
  not(i_69, S0);
  and(i_70, i_71, S0);
  and(i_71, B, i_72);
  not(i_72, S1);
  and(i_73, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X2_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_64);
  or(i_64, i_65, i_73);
  or(i_65, i_66, i_70);
  and(i_66, i_67, i_69);
  and(i_67, A, i_68);
  not(i_68, S1);
  not(i_69, S0);
  and(i_70, i_71, S0);
  and(i_71, B, i_72);
  not(i_72, S1);
  and(i_73, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X3_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_97);
  or(i_97, i_98, i_106);
  or(i_98, i_99, i_103);
  and(i_99, i_100, i_102);
  and(i_100, A, i_101);
  not(i_101, S1);
  not(i_102, S0);
  and(i_103, i_104, S0);
  and(i_104, B, i_105);
  not(i_105, S1);
  and(i_106, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X4_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_55);
  or(i_55, i_56, i_64);
  or(i_56, i_57, i_61);
  and(i_57, i_58, i_60);
  and(i_58, A, i_59);
  not(i_59, S1);
  not(i_60, S0);
  and(i_61, i_62, S0);
  and(i_62, B, i_63);
  not(i_63, S1);
  and(i_64, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X6_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_97);
  or(i_97, i_98, i_106);
  or(i_98, i_99, i_103);
  and(i_99, i_100, i_102);
  and(i_100, A, i_101);
  not(i_101, S1);
  not(i_102, S0);
  and(i_103, i_104, S0);
  and(i_104, B, i_105);
  not(i_105, S1);
  and(i_106, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X8_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_64);
  or(i_64, i_65, i_73);
  or(i_65, i_66, i_70);
  and(i_66, i_67, i_69);
  and(i_67, A, i_68);
  not(i_68, S1);
  not(i_69, S0);
  and(i_70, i_71, S0);
  and(i_71, B, i_72);
  not(i_72, S1);
  and(i_73, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X1_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X2_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_99);
  or(i_99, i_100, i_111);
  or(i_100, i_101, i_109);
  or(i_101, i_102, i_106);
  and(i_102, i_103, i_105);
  and(i_103, A, i_104);
  not(i_104, S1);
  not(i_105, S0);
  and(i_106, i_107, S0);
  and(i_107, B, i_108);
  not(i_108, S1);
  and(i_109, i_110, S0);
  and(i_110, D, S1);
  and(i_111, i_112, i_113);
  and(i_112, C, S1);
  not(i_113, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X3_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_99);
  or(i_99, i_100, i_111);
  or(i_100, i_101, i_109);
  or(i_101, i_102, i_106);
  and(i_102, i_103, i_105);
  and(i_103, A, i_104);
  not(i_104, S1);
  not(i_105, S0);
  and(i_106, i_107, S0);
  and(i_107, B, i_108);
  not(i_108, S1);
  and(i_109, i_110, S0);
  and(i_110, D, S1);
  and(i_111, i_112, i_113);
  and(i_112, C, S1);
  not(i_113, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X4_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X6_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X8_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVXL_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX1_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX2_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX3_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX4_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX6_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX8_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX12_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX16_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX24_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX32_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

primitive \seq_LGNX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           1           0           ?       : ? :           0;
           1           1           ?       : ? :           1;
           0           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGNX1_HV (CLK, E, GCK);
  input CLK;
  input E;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGNX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK_d, i_78);
    and(i_78, i_79, i_80);
    not(i_79, CLK_d);
    not(i_80, ENL);
    buf(nextstate, E_d);

  `else
    \seq_LGNX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK, i_78);
    and(i_78, i_79, i_80);
    not(i_79, CLK);
    not(i_80, ENL);
    buf(nextstate, E);

  `endif

  specify
    if((E == 1'b0)) (posedge CLK => (GCK +: 1'b1)) = (0.0, 0.0);
    if((E == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGPX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           0           0           ?       : ? :           0;
           0           1           ?       : ? :           1;
           1           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGPX1_HV (CLK, E, GCK);
  input CLK;
  input E;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGPX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK_d, ENL);
    buf(nextstate, E_d);

  `else
    \seq_LGPX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK, ENL);
    buf(nextstate, E);

  `endif

  specify
    if((E == 1'b0)) (negedge CLK => (GCK +: 1'b0)) = (0.0, 0.0);
    if((E == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGSNX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           1           0           ?       : ? :           0;
           1           1           ?       : ? :           1;
           0           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGSNX1_HV (CLK, E, SE, GCK);
  input CLK;
  input E;
  input SE;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGSNX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK_d, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK_d);
    not(i_14, ENL);
    or(nextstate, E_d, SE_d);

  `else
    \seq_LGSNX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK);
    not(i_14, ENL);
    or(nextstate, E, SE);

  `endif

  specify
    if((E == 1'b0) && (SE == 1'b0)) (posedge CLK => (GCK +: 1'b1)) = (0.0, 0.0);
    if((E == 1'b0) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b0)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, negedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, posedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGSPX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           0           0           ?       : ? :           0;
           0           1           ?       : ? :           1;
           1           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGSPX1_HV (CLK, E, SE, GCK);
  input CLK;
  input E;
  input SE;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGSPX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK_d, ENL);
    or(nextstate, E_d, SE_d);

  `else
    \seq_LGSPX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK, ENL);
    or(nextstate, E, SE);

  `endif

  specify
    if((E == 1'b0) && (SE == 1'b0)) (negedge CLK => (GCK +: 1'b0)) = (0.0, 0.0);
    if((E == 1'b0) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b0)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, negedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, posedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX1_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX1_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX1_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX1_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX2_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX2_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX2_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LHCPX2_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX3_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX3_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX3_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX3_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX4_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX4_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX4_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX4_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX6_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX6_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX6_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX6_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX1_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX1_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX1_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX1_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX2_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX2_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX2_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX2_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX3_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX3_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX3_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX3_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX4_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX4_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX4_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_LHCX4_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_23), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_22), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX6_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX6_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX6_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX6_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX1_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX1_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX1_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX1_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX2_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX2_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX2_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX2_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX3_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX3_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX3_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LHPX3_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX4_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX4_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX4_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX4_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX6_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX6_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX6_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_29, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    \seq_LHPX6_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_28, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_28, id_28, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_29), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_29), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_29), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_28), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX1_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX1_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX1_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX1_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX2_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX2_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX2_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX2_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX3_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX3_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX3_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX3_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX4_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX4_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX4_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX4_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX6_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX6_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX6_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX6_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX1_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX1_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX1_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX1_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX2_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX2_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX2_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX2_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX3_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX3_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX3_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_23, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_LNCPX3_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_22, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_23), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_22), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX4_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX4_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX4_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX4_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX6_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX6_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX6_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX6_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX1_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX1_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX1_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCX1_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX2_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX2_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX2_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCX2_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX3_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX3_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX3_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNCX3_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX4_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX4_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX4_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCX4_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX6_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX6_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX6_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_29, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    \seq_LNCX6_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_28, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_28, id_28, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_29), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_29), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_29), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_28), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX1_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX1_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX1_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNPX1_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX2_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX2_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX2_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_17, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LNPX2_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_16, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX3_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX3_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX3_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNPX3_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX4_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX4_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX4_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNPX4_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX6_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX6_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX6_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_LNPX6_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_23), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_22), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX1_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX1_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX1_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX1_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX2_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX2_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX2_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX2_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX3_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX3_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX3_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX3_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX4_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX4_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX4_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX4_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX6_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX6_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX6_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX6_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

module MAJ3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_337, i_340);
  or(i_337, i_338, i_339);
  and(i_338, B, A);
  and(i_339, C, B);
  and(i_340, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_46, i_49);
  or(i_46, i_47, i_48);
  and(i_47, B, A);
  and(i_48, C, B);
  and(i_49, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_148, i_151);
  or(i_148, i_149, i_150);
  and(i_149, B, A);
  and(i_150, C, B);
  and(i_151, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_64, i_67);
  or(i_64, i_65, i_66);
  and(i_65, B, A);
  and(i_66, C, B);
  and(i_67, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X1_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_96, i_98);
  and(i_96, A, i_97);
  not(i_97, S);
  and(i_98, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X2_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_150, i_152);
  and(i_150, A, i_151);
  not(i_151, S);
  and(i_152, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X3_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_30, i_32);
  and(i_30, A, i_31);
  not(i_31, S);
  and(i_32, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X4_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_30, i_32);
  and(i_30, A, i_31);
  not(i_31, S);
  and(i_32, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X6_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_66, i_68);
  and(i_66, A, i_67);
  not(i_67, S);
  and(i_68, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X8_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_204, i_206);
  and(i_204, A, i_205);
  not(i_205, S);
  and(i_206, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X1_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_165, i_173);
  or(i_165, i_166, i_170);
  and(i_166, i_167, i_169);
  and(i_167, A, i_168);
  not(i_168, S1);
  not(i_169, S0);
  and(i_170, i_171, S0);
  and(i_171, B, i_172);
  not(i_172, S1);
  and(i_173, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X2_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_60, i_68);
  or(i_60, i_61, i_65);
  and(i_61, i_62, i_64);
  and(i_62, A, i_63);
  not(i_63, S1);
  not(i_64, S0);
  and(i_65, i_66, S0);
  and(i_66, B, i_67);
  not(i_67, S1);
  and(i_68, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X3_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_36, i_44);
  or(i_36, i_37, i_41);
  and(i_37, i_38, i_40);
  and(i_38, A, i_39);
  not(i_39, S1);
  not(i_40, S0);
  and(i_41, i_42, S0);
  and(i_42, B, i_43);
  not(i_43, S1);
  and(i_44, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X4_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_78, i_86);
  or(i_78, i_79, i_83);
  and(i_79, i_80, i_82);
  and(i_80, A, i_81);
  not(i_81, S1);
  not(i_82, S0);
  and(i_83, i_84, S0);
  and(i_84, B, i_85);
  not(i_85, S1);
  and(i_86, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X6_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_54, i_62);
  or(i_54, i_55, i_59);
  and(i_55, i_56, i_58);
  and(i_56, A, i_57);
  not(i_57, S1);
  not(i_58, S0);
  and(i_59, i_60, S0);
  and(i_60, B, i_61);
  not(i_61, S1);
  and(i_62, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X8_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_36, i_44);
  or(i_36, i_37, i_41);
  and(i_37, i_38, i_40);
  and(i_38, A, i_39);
  not(i_39, S1);
  not(i_40, S0);
  and(i_41, i_42, S0);
  and(i_42, B, i_43);
  not(i_43, S1);
  and(i_44, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X1_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X2_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X3_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X4_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X6_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_74, i_85);
  or(i_74, i_75, i_83);
  or(i_75, i_76, i_80);
  and(i_76, i_77, i_79);
  and(i_77, A, i_78);
  not(i_78, S1);
  not(i_79, S0);
  and(i_80, i_81, S0);
  and(i_81, B, i_82);
  not(i_82, S1);
  and(i_83, i_84, S0);
  and(i_84, D, S1);
  and(i_85, i_86, i_87);
  and(i_86, C, S1);
  not(i_87, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X8_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2XL_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_154);
  and(i_154, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_157);
  and(i_157, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_70);
  and(i_70, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_52);
  and(i_52, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_52);
  and(i_52, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_142);
  and(i_142, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_142);
  and(i_142, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X12_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_280);
  and(i_280, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_62);
  and(i_62, i_63, C);
  and(i_63, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_83);
  and(i_83, i_84, C);
  and(i_84, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_50);
  and(i_50, i_51, C);
  and(i_51, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_44);
  and(i_44, i_45, C);
  and(i_45, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_134);
  and(i_134, i_135, C);
  and(i_135, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_50);
  and(i_50, i_51, C);
  and(i_51, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X12_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_98);
  and(i_98, i_99, C);
  and(i_99, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_144);
  and(i_144, i_145, D);
  and(i_145, i_146, C);
  and(i_146, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_120);
  and(i_120, i_121, D);
  and(i_121, i_122, C);
  and(i_122, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_117);
  and(i_117, i_118, D);
  and(i_118, i_119, C);
  and(i_119, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_30);
  and(i_30, i_31, D);
  and(i_31, i_32, C);
  and(i_32, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_12);
  and(i_12, i_13, D);
  and(i_13, i_14, C);
  and(i_14, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_36);
  and(i_36, i_37, D);
  and(i_37, i_38, C);
  and(i_38, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2XL_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_163);
  or(i_163, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_124);
  or(i_124, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_130);
  or(i_130, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_4);
  or(i_4, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_40);
  or(i_40, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_94);
  or(i_94, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_160);
  or(i_160, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X12_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_94);
  or(i_94, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_32);
  or(i_32, i_33, C);
  or(i_33, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_44);
  or(i_44, i_45, C);
  or(i_45, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_44);
  or(i_44, i_45, C);
  or(i_45, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_44);
  or(i_44, i_45, C);
  or(i_45, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_26);
  or(i_26, i_27, C);
  or(i_27, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_128);
  or(i_128, i_129, C);
  or(i_129, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X12_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_122);
  or(i_122, i_123, C);
  or(i_123, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_102);
  or(i_102, i_103, D);
  or(i_103, i_104, C);
  or(i_104, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, D);
  or(i_61, i_62, C);
  or(i_62, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, D);
  or(i_61, i_62, C);
  or(i_62, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_30);
  or(i_30, i_31, D);
  or(i_31, i_32, C);
  or(i_32, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_12);
  or(i_12, i_13, D);
  or(i_13, i_14, C);
  or(i_14, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_108);
  or(i_108, i_109, D);
  or(i_109, i_110, C);
  or(i_110, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_134);
  and(i_134, i_135, B1);
  or(i_135, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_134);
  and(i_134, i_135, B1);
  or(i_135, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_56);
  and(i_56, i_57, B1);
  or(i_57, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_26);
  and(i_26, i_27, B1);
  or(i_27, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_131);
  and(i_131, i_132, B1);
  or(i_132, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_197);
  and(i_197, i_198, B1);
  or(i_198, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_30);
  and(i_30, i_31, i_32);
  or(i_31, A1, A2);
  or(i_32, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_12);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_30);
  and(i_30, i_31, i_32);
  or(i_31, A1, A2);
  or(i_32, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_96);
  and(i_96, i_97, i_98);
  or(i_97, A1, A2);
  or(i_98, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_48);
  and(i_48, i_49, i_50);
  or(i_49, A1, A2);
  or(i_50, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_36);
  and(i_36, i_37, i_38);
  or(i_37, A1, A2);
  or(i_38, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_54);
  and(i_54, i_55, B1);
  or(i_55, i_56, A3);
  or(i_56, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_12);
  and(i_12, i_13, B1);
  or(i_13, i_14, A3);
  or(i_14, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_12);
  and(i_12, i_13, B1);
  or(i_13, i_14, A3);
  or(i_14, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_30);
  and(i_30, i_31, B1);
  or(i_31, i_32, A3);
  or(i_32, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_24);
  and(i_24, i_25, B1);
  or(i_25, i_26, A3);
  or(i_26, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_150);
  and(i_150, i_151, B1);
  or(i_151, i_152, A3);
  or(i_152, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, i_19);
  or(i_17, i_18, A3);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_40);
  and(i_40, i_41, i_43);
  or(i_41, i_42, A3);
  or(i_42, A1, A2);
  or(i_43, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, i_19);
  or(i_17, i_18, A3);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, i_19);
  or(i_17, i_18, A3);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, i_19);
  or(i_17, i_18, A3);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, i_19);
  or(i_17, i_18, A3);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_108);
  and(i_108, i_109, C1);
  and(i_109, i_110, B1);
  or(i_110, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_12);
  and(i_12, i_13, C1);
  and(i_13, i_14, B1);
  or(i_14, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_54);
  and(i_54, i_55, C1);
  and(i_55, i_56, B1);
  or(i_56, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_69);
  and(i_69, i_70, C1);
  and(i_70, i_71, B1);
  or(i_71, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_30);
  and(i_30, i_31, C1);
  and(i_31, i_32, B1);
  or(i_32, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_12);
  and(i_12, i_13, C1);
  and(i_13, i_14, B1);
  or(i_14, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, i_19);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, i_19);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, i_19);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, i_19);
  or(i_18, A1, A2);
  or(i_19, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_97);
  and(i_97, i_98, C1);
  and(i_98, i_99, i_100);
  or(i_99, A1, A2);
  or(i_100, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_64);
  and(i_64, i_65, C1);
  and(i_65, i_66, i_67);
  or(i_66, A1, A2);
  or(i_67, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X1_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, B1);
  or(i_18, i_19, A3);
  or(i_19, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X2_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, B1);
  or(i_18, i_19, A3);
  or(i_19, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X3_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, B1);
  or(i_18, i_19, A3);
  or(i_19, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X4_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_64);
  and(i_64, i_65, C1);
  and(i_65, i_66, B1);
  or(i_66, i_67, A3);
  or(i_67, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X6_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_49);
  and(i_49, i_50, C1);
  and(i_50, i_51, B1);
  or(i_51, i_52, A3);
  or(i_52, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X8_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, B1);
  or(i_18, i_19, A3);
  or(i_19, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_112, B1);
  or(i_112, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_22, B1);
  or(i_22, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_58, B1);
  or(i_58, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_64, B1);
  or(i_64, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_118, B1);
  or(i_118, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_88, B1);
  or(i_88, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_122, i_123);
  or(i_122, A1, A2);
  or(i_123, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_209, i_210);
  or(i_209, A1, A2);
  or(i_210, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_62, i_63);
  or(i_62, A1, A2);
  or(i_63, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_8, i_9);
  or(i_8, A1, A2);
  or(i_9, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_110, i_111);
  or(i_110, A1, A2);
  or(i_111, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_110, i_111);
  or(i_110, A1, A2);
  or(i_111, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_32, B1);
  or(i_32, i_33, A3);
  or(i_33, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_104, B1);
  or(i_104, i_105, A3);
  or(i_105, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_44, B1);
  or(i_44, i_45, A3);
  or(i_45, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_32, B1);
  or(i_32, i_33, A3);
  or(i_33, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_44, B1);
  or(i_44, i_45, A3);
  or(i_45, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_92, B1);
  or(i_92, i_93, A3);
  or(i_93, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_12, i_14);
  or(i_12, i_13, A3);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_36, i_38);
  or(i_36, i_37, A3);
  or(i_37, A1, A2);
  or(i_38, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_12, i_14);
  or(i_12, i_13, A3);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_27, i_29);
  or(i_27, i_28, A3);
  or(i_28, A1, A2);
  or(i_29, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_12, i_14);
  or(i_12, i_13, A3);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_12, i_14);
  or(i_12, i_13, A3);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_92, C1);
  and(i_92, i_93, B1);
  or(i_93, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_104, C1);
  and(i_104, i_105, B1);
  or(i_105, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_32, C1);
  and(i_32, i_33, B1);
  or(i_33, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_92, C1);
  and(i_92, i_93, B1);
  or(i_93, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_110, C1);
  and(i_110, i_111, B1);
  or(i_111, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_131, C1);
  and(i_131, i_132, B1);
  or(i_132, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_51, C1);
  and(i_51, i_52, i_53);
  or(i_52, A1, A2);
  or(i_53, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_12, C1);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_12, C1);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_12, C1);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_12, C1);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_12, C1);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_4, C);
  or(i_4, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_88, C);
  or(i_88, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_160, C);
  or(i_160, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_52, C);
  or(i_52, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_82, C);
  or(i_82, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_22, C);
  or(i_22, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module TIE0_HV (Q);
  output Q;

  buf(Q, 0);
endmodule

module TIE1_HV (Q);
  output Q;

  buf(Q, 1);
endmodule

module XNOR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_130);
  xor(i_130, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_160);
  xor(i_160, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_148);
  xor(i_148, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_46);
  xor(i_46, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_70);
  xor(i_70, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_142);
  xor(i_142, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_291);
  not(i_291, i_292);
  or(i_292, i_293, i_299);
  and(i_293, i_294, C);
  not(i_294, i_295);
  or(i_295, i_296, i_297);
  and(i_296, A, B);
  not(i_297, i_298);
  or(i_298, A, B);
  not(i_299, i_300);
  or(i_300, i_301, C);
  not(i_301, i_302);
  or(i_302, i_303, i_304);
  and(i_303, A, B);
  not(i_304, i_305);
  or(i_305, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_90);
  not(i_90, i_91);
  or(i_91, i_92, i_98);
  and(i_92, i_93, C);
  not(i_93, i_94);
  or(i_94, i_95, i_96);
  and(i_95, A, B);
  not(i_96, i_97);
  or(i_97, A, B);
  not(i_98, i_99);
  or(i_99, i_100, C);
  not(i_100, i_101);
  or(i_101, i_102, i_103);
  and(i_102, A, B);
  not(i_103, i_104);
  or(i_104, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_168);
  not(i_168, i_169);
  or(i_169, i_170, i_176);
  and(i_170, i_171, C);
  not(i_171, i_172);
  or(i_172, i_173, i_174);
  and(i_173, A, B);
  not(i_174, i_175);
  or(i_175, A, B);
  not(i_176, i_177);
  or(i_177, i_178, C);
  not(i_178, i_179);
  or(i_179, i_180, i_181);
  and(i_180, A, B);
  not(i_181, i_182);
  or(i_182, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_240);
  not(i_240, i_241);
  or(i_241, i_242, i_248);
  and(i_242, i_243, C);
  not(i_243, i_244);
  or(i_244, i_245, i_246);
  and(i_245, A, B);
  not(i_246, i_247);
  or(i_247, A, B);
  not(i_248, i_249);
  or(i_249, i_250, C);
  not(i_250, i_251);
  or(i_251, i_252, i_253);
  and(i_252, A, B);
  not(i_253, i_254);
  or(i_254, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_72);
  not(i_72, i_73);
  or(i_73, i_74, i_80);
  and(i_74, i_75, C);
  not(i_75, i_76);
  or(i_76, i_77, i_78);
  and(i_77, A, B);
  not(i_78, i_79);
  or(i_79, A, B);
  not(i_80, i_81);
  or(i_81, i_82, C);
  not(i_82, i_83);
  or(i_83, i_84, i_85);
  and(i_84, A, B);
  not(i_85, i_86);
  or(i_86, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_216);
  not(i_216, i_217);
  or(i_217, i_218, i_224);
  and(i_218, i_219, C);
  not(i_219, i_220);
  or(i_220, i_221, i_222);
  and(i_221, A, B);
  not(i_222, i_223);
  or(i_223, A, B);
  not(i_224, i_225);
  or(i_225, i_226, C);
  not(i_226, i_227);
  or(i_227, i_228, i_229);
  and(i_228, A, B);
  not(i_229, i_230);
  or(i_230, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4XL_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_195);
  xor(i_195, i_196, A);
  xor(i_196, i_197, B);
  xor(i_197, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_153);
  xor(i_153, i_154, A);
  xor(i_154, i_155, B);
  xor(i_155, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_117);
  xor(i_117, i_118, A);
  xor(i_118, i_119, B);
  xor(i_119, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_135);
  xor(i_135, i_136, A);
  xor(i_136, i_137, B);
  xor(i_137, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_108);
  xor(i_108, i_109, A);
  xor(i_109, i_110, B);
  xor(i_110, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_87);
  xor(i_87, i_88, A);
  xor(i_88, i_89, B);
  xor(i_89, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_60);
  xor(i_60, i_61, A);
  xor(i_61, i_62, B);
  xor(i_62, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2XL_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_151);
  or(i_151, i_152, i_153);
  and(i_152, A, B);
  not(i_153, i_154);
  or(i_154, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_325);
  or(i_325, i_326, i_327);
  and(i_326, A, B);
  not(i_327, i_328);
  or(i_328, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_268);
  or(i_268, i_269, i_270);
  and(i_269, A, B);
  not(i_270, i_271);
  or(i_271, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_109);
  or(i_109, i_110, i_111);
  and(i_110, A, B);
  not(i_111, i_112);
  or(i_112, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_88);
  or(i_88, i_89, i_90);
  and(i_89, A, B);
  not(i_90, i_91);
  or(i_91, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_232);
  or(i_232, i_233, i_234);
  and(i_233, A, B);
  not(i_234, i_235);
  or(i_235, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_361);
  or(i_361, i_362, i_363);
  and(i_362, A, B);
  not(i_363, i_364);
  or(i_364, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3XL_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_92);
  or(i_92, i_93, i_99);
  and(i_93, i_94, C);
  not(i_94, i_95);
  or(i_95, i_96, i_97);
  and(i_96, A, B);
  not(i_97, i_98);
  or(i_98, A, B);
  not(i_99, i_100);
  or(i_100, i_101, C);
  not(i_101, i_102);
  or(i_102, i_103, i_104);
  and(i_103, A, B);
  not(i_104, i_105);
  or(i_105, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_164);
  or(i_164, i_165, i_171);
  and(i_165, i_166, C);
  not(i_166, i_167);
  or(i_167, i_168, i_169);
  and(i_168, A, B);
  not(i_169, i_170);
  or(i_170, A, B);
  not(i_171, i_172);
  or(i_172, i_173, C);
  not(i_173, i_174);
  or(i_174, i_175, i_176);
  and(i_175, A, B);
  not(i_176, i_177);
  or(i_177, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_212);
  or(i_212, i_213, i_219);
  and(i_213, i_214, C);
  not(i_214, i_215);
  or(i_215, i_216, i_217);
  and(i_216, A, B);
  not(i_217, i_218);
  or(i_218, A, B);
  not(i_219, i_220);
  or(i_220, i_221, C);
  not(i_221, i_222);
  or(i_222, i_223, i_224);
  and(i_223, A, B);
  not(i_224, i_225);
  or(i_225, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_116);
  or(i_116, i_117, i_123);
  and(i_117, i_118, C);
  not(i_118, i_119);
  or(i_119, i_120, i_121);
  and(i_120, A, B);
  not(i_121, i_122);
  or(i_122, A, B);
  not(i_123, i_124);
  or(i_124, i_125, C);
  not(i_125, i_126);
  or(i_126, i_127, i_128);
  and(i_127, A, B);
  not(i_128, i_129);
  or(i_129, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_68);
  or(i_68, i_69, i_75);
  and(i_69, i_70, C);
  not(i_70, i_71);
  or(i_71, i_72, i_73);
  and(i_72, A, B);
  not(i_73, i_74);
  or(i_74, A, B);
  not(i_75, i_76);
  or(i_76, i_77, C);
  not(i_77, i_78);
  or(i_78, i_79, i_80);
  and(i_79, A, B);
  not(i_80, i_81);
  or(i_81, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_92);
  or(i_92, i_93, i_99);
  and(i_93, i_94, C);
  not(i_94, i_95);
  or(i_95, i_96, i_97);
  and(i_96, A, B);
  not(i_97, i_98);
  or(i_98, A, B);
  not(i_99, i_100);
  or(i_100, i_101, C);
  not(i_101, i_102);
  or(i_102, i_103, i_104);
  and(i_103, A, B);
  not(i_104, i_105);
  or(i_105, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_128);
  or(i_128, i_129, i_135);
  and(i_129, i_130, C);
  not(i_130, i_131);
  or(i_131, i_132, i_133);
  and(i_132, A, B);
  not(i_133, i_134);
  or(i_134, A, B);
  not(i_135, i_136);
  or(i_136, i_137, C);
  not(i_137, i_138);
  or(i_138, i_139, i_140);
  and(i_139, A, B);
  not(i_140, i_141);
  or(i_141, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4XL_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_32, A);
  xor(i_32, i_33, B);
  xor(i_33, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_32, A);
  xor(i_32, i_33, B);
  xor(i_33, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_98, A);
  xor(i_98, i_99, B);
  xor(i_99, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_26, A);
  xor(i_26, i_27, B);
  xor(i_27, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_32, A);
  xor(i_32, i_33, B);
  xor(i_33, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_8, A);
  xor(i_8, i_9, B);
  xor(i_9, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_92, A);
  xor(i_92, i_93, B);
  xor(i_93, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule


module BUFG2_ESDIF_HV (A, G, Q);
  input A;
  input G;
  output Q;

  and(Q, A, G);

  specify
    (A => Q) = (0.0, 0.0);
    (G => Q) = (0.0, 0.0);
  endspecify

endmodule


module BUF2_ESDIF_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module ESDIFP5_HV (IN, OUT);
  input IN;
  output OUT;
endmodule


module LOGIC0_HV (Q);
 output Q;

 buf (Q,0);

endmodule


module LOGIC1_HV (Q);
 output Q;

 buf (Q,1);

endmodule

`ifdef TETRAMAX
`else
  primitive ng_xbuf (o, i, d);
	output o;
	input i, d;
	table
	// i   d   : o
	   0   1   : 0 ;
	   1   1   : 1 ;
	   x   1   : 1 ;
	endtable
  endprimitive
`endif
//
// End of file
//
