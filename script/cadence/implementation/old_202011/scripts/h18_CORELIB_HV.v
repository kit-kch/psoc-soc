// 
// ******************************************************************************
// *                                                                            *
// *                   Copyright (C) 2004-2013, Nangate Inc.                    *
// *                           All rights reserved.                             *
// *                                                                            *
// * Nangate and the Nangate logo are trademarks of Nangate Inc.                *
// *                                                                            *
// * All trademarks, logos, software marks, and trade names (collectively the   *
// * "Marks") in this program are proprietary to Nangate or other respective    *
// * owners that have granted Nangate the right and license to use such Marks.  *
// * You are not permitted to use the Marks without the prior written consent   *
// * of Nangate or such third party that may own the Marks.                     *
// *                                                                            *
// * This file has been provided pursuant to a License Agreement containing     *
// * restrictions on its use. This file contains valuable trade secrets and     *
// * proprietary information of Nangate Inc., and is protected by U.S. and      *
// * international laws and/or treaties.                                        *
// *                                                                            *
// * The copyright notice(s) in this file does not indicate actual or intended  *
// * publication of this file.                                                  *
// *                                                                            *
// *NGLibraryCharacterizer, v2012.06-QR02-SP2-2012-12-07-abr_32 - build 1212291518*
// *                                                                            *
// ******************************************************************************
// 
// 
// Running on du31694l for user Bodo Kaufmann (bka).
// Local time is now Tue, 5 Mar 2013, 16:11:21.
// Main process id is 14113.
// 
// * Default delays
//   * comb. path delay        : 0.0
//   * seq. path delay         : 0.0
//   * delay cells             : 0.0
//   * timing checks           : 0.0
// 
// * NTC Setup
//   * Export NTC sections     : true
//   * Combine setup / hold    : true
//   * Combine recovery/removal: true
// 
// * Extras
//   * Export `celldefine      : false
//   * Export `timescale       : -
// 

`timescale 1ns/1ps
`celldefine

`define NTC
`define RECREM


module AND2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_400, C);
  and(i_400, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_400, C);
  and(i_400, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_346, C);
  and(i_346, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_334, C);
  and(i_334, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_163, C);
  and(i_163, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_374, C);
  and(i_374, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_200);
  or(i_200, i_201, B1);
  and(i_201, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_422);
  or(i_422, i_423, B1);
  and(i_423, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_260);
  or(i_260, i_261, B1);
  and(i_261, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_218);
  or(i_218, i_219, B1);
  and(i_219, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_254);
  or(i_254, i_255, B1);
  and(i_255, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_152);
  or(i_152, i_153, B1);
  and(i_153, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_258);
  or(i_258, i_259, i_260);
  and(i_259, A1, A2);
  and(i_260, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_222);
  or(i_222, i_223, i_224);
  and(i_223, A1, A2);
  and(i_224, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_168);
  or(i_168, i_169, i_170);
  and(i_169, A1, A2);
  and(i_170, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_150);
  or(i_150, i_151, i_152);
  and(i_151, A1, A2);
  and(i_152, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_366);
  or(i_366, i_367, i_368);
  and(i_367, A1, A2);
  and(i_368, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_267);
  or(i_267, i_268, i_269);
  and(i_268, A1, A2);
  and(i_269, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_294);
  or(i_294, i_295, B1);
  and(i_295, i_296, A3);
  and(i_296, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_258);
  or(i_258, i_259, B1);
  and(i_259, i_260, A3);
  and(i_260, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_240);
  or(i_240, i_241, B1);
  and(i_241, i_242, A3);
  and(i_242, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_78);
  or(i_78, i_79, B1);
  and(i_79, i_80, A3);
  and(i_80, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_351);
  or(i_351, i_352, B1);
  and(i_352, i_353, A3);
  and(i_353, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_210);
  or(i_210, i_211, B1);
  and(i_211, i_212, A3);
  and(i_212, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_184);
  or(i_184, i_185, i_187);
  and(i_185, i_186, A3);
  and(i_186, A1, A2);
  and(i_187, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_115);
  or(i_115, i_116, i_118);
  and(i_116, i_117, A3);
  and(i_117, A1, A2);
  and(i_118, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_166);
  or(i_166, i_167, i_169);
  and(i_167, i_168, A3);
  and(i_168, A1, A2);
  and(i_169, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_16);
  or(i_16, i_17, i_19);
  and(i_17, i_18, A3);
  and(i_18, A1, A2);
  and(i_19, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_160);
  or(i_160, i_161, i_163);
  and(i_161, i_162, A3);
  and(i_162, A1, A2);
  and(i_163, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_178);
  or(i_178, i_179, i_181);
  and(i_179, i_180, A3);
  and(i_180, A1, A2);
  and(i_181, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_96);
  or(i_96, i_97, C1);
  or(i_97, i_98, B1);
  and(i_98, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_183);
  or(i_183, i_184, C1);
  or(i_184, i_185, B1);
  and(i_185, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_246);
  or(i_246, i_247, C1);
  or(i_247, i_248, B1);
  and(i_248, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_102);
  or(i_102, i_103, C1);
  or(i_103, i_104, B1);
  and(i_104, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_180);
  or(i_180, i_181, C1);
  or(i_181, i_182, B1);
  and(i_182, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_312);
  or(i_312, i_313, C1);
  or(i_313, i_314, B1);
  and(i_314, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_127);
  or(i_127, i_128, C1);
  or(i_128, i_129, i_130);
  and(i_129, A1, A2);
  and(i_130, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_190);
  or(i_190, i_191, C1);
  or(i_191, i_192, i_193);
  and(i_192, A1, A2);
  and(i_193, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_160);
  or(i_160, i_161, C1);
  or(i_161, i_162, i_163);
  and(i_162, A1, A2);
  and(i_163, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_178);
  or(i_178, i_179, C1);
  or(i_179, i_180, i_181);
  and(i_180, A1, A2);
  and(i_181, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_139);
  or(i_139, i_140, C1);
  or(i_140, i_141, i_142);
  and(i_141, A1, A2);
  and(i_142, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_130);
  or(i_130, i_131, C1);
  or(i_131, i_132, i_133);
  and(i_132, A1, A2);
  and(i_133, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X1_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_160);
  or(i_160, i_161, C1);
  or(i_161, i_162, B1);
  and(i_162, i_163, A3);
  and(i_163, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X2_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_67);
  or(i_67, i_68, C1);
  or(i_68, i_69, B1);
  and(i_69, i_70, A3);
  and(i_70, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X3_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_196);
  or(i_196, i_197, C1);
  or(i_197, i_198, B1);
  and(i_198, i_199, A3);
  and(i_199, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X4_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_70);
  or(i_70, i_71, C1);
  or(i_71, i_72, B1);
  and(i_72, i_73, A3);
  and(i_73, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X6_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_158);
  or(i_158, i_159, C1);
  or(i_159, i_160, B1);
  and(i_160, i_161, A3);
  and(i_161, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X8_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_268);
  or(i_268, i_269, C1);
  or(i_269, i_270, B1);
  and(i_270, i_271, A3);
  and(i_271, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_394, B1);
  and(i_394, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_157, B1);
  and(i_157, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_412, B1);
  and(i_412, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_160, B1);
  and(i_160, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_190, B1);
  and(i_190, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_316, B1);
  and(i_316, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_248, i_249);
  and(i_248, A1, A2);
  and(i_249, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_335, i_336);
  and(i_335, A1, A2);
  and(i_336, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_194, i_195);
  and(i_194, A1, A2);
  and(i_195, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_350, i_351);
  and(i_350, A1, A2);
  and(i_351, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_278, i_279);
  and(i_278, A1, A2);
  and(i_279, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_206, i_207);
  and(i_206, A1, A2);
  and(i_207, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_62, B1);
  and(i_62, i_63, A3);
  and(i_63, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_140, B1);
  and(i_140, i_141, A3);
  and(i_141, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_251, B1);
  and(i_251, i_252, A3);
  and(i_252, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_242, B1);
  and(i_242, i_243, A3);
  and(i_243, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_323, B1);
  and(i_323, i_324, A3);
  and(i_324, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_266, B1);
  and(i_266, i_267, A3);
  and(i_267, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_90, i_92);
  and(i_90, i_91, A3);
  and(i_91, A1, A2);
  and(i_92, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_168, i_170);
  and(i_168, i_169, A3);
  and(i_169, A1, A2);
  and(i_170, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_150, i_152);
  and(i_150, i_151, A3);
  and(i_151, A1, A2);
  and(i_152, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_144, i_146);
  and(i_144, i_145, A3);
  and(i_145, A1, A2);
  and(i_146, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_136, i_138);
  and(i_136, i_137, A3);
  and(i_137, A1, A2);
  and(i_138, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_99, i_101);
  and(i_99, i_100, A3);
  and(i_100, A1, A2);
  and(i_101, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_86, C1);
  or(i_86, i_87, B1);
  and(i_87, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_230, C1);
  or(i_230, i_231, B1);
  and(i_231, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_194, C1);
  or(i_194, i_195, B1);
  and(i_195, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_182, C1);
  or(i_182, i_183, B1);
  and(i_183, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_230, C1);
  or(i_230, i_231, B1);
  and(i_231, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_167, C1);
  or(i_167, i_168, B1);
  and(i_168, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_30, C1);
  or(i_30, i_31, i_32);
  and(i_31, A1, A2);
  and(i_32, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_30, C1);
  or(i_30, i_31, i_32);
  and(i_31, A1, A2);
  and(i_32, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_117, C1);
  or(i_117, i_118, i_119);
  and(i_118, A1, A2);
  and(i_119, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_219, C1);
  or(i_219, i_220, i_221);
  and(i_220, A1, A2);
  and(i_221, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_90, C1);
  or(i_90, i_91, i_92);
  and(i_91, A1, A2);
  and(i_92, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_156, C1);
  or(i_156, i_157, i_158);
  and(i_157, A1, A2);
  and(i_158, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFEX2_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX4_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX6_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX8_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX10_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX12_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX16_HV (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX2_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX4_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX6_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX8_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX10_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX12_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX16_HV (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFX2_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX3_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX4_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX6_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX8_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX12_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX16_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX24_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX32_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUSHDX1_HV (A);
  inout A;

  buf(A, A);
endmodule

module CLKBUFX2_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX3_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX4_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX6_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX8_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX10_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX12_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX16_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX24_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX32_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX1_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX2_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX3_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX4_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX6_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX8_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX10_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX12_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX16_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX24_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX32_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

primitive \seq_DFCPSX1_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX1_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
 #1       IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end




  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPSX1_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_50, i_51);
    not(i_50, IQ);
    not(i_51, i_52);
    and(i_52, i_53, i_54);
    not(i_53, SN_d);
    not(i_54, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_55, i_56);
    and(i_55, SE_d, SI_d);
    and(i_56, i_57, D_d);
    not(i_57, SE_d);

    // Delayed data/reference logic
    and(id_45, SN_d, RN_d);
    and(id_46, id_45, i_62);
    not(i_62, SE_d);
    and(id_47, id_45, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_45, id_45, 1'b1);
      ng_xbuf(xid_46, id_46, 1'b1);
      ng_xbuf(xid_47, id_47, 1'b1);
    `endif
  `else
    //\seq_DFCPSX1_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_50, i_51);
    not(i_50, IQ);
    not(i_51, i_52);
    and(i_52, i_53, i_54);
    not(i_53, SN);
    not(i_54, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_55, i_56);
    and(i_55, SE, SI);
    and(i_56, i_57, D);
    not(i_57, SE);

    // Delayed data/reference logic
    and(id_42, SN, RN);
    and(id_43, id_42, i_61);
    not(i_61, SE);
    and(id_44, id_42, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_42, id_42, 1'b1);
      ng_xbuf(xid_43, id_43, 1'b1);
      ng_xbuf(xid_44, id_44, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_46), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_46), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_47), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_47), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX2_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX2_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPSX2_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_107, i_108);
    not(i_107, IQ);
    not(i_108, i_109);
    and(i_109, i_110, i_111);
    not(i_110, SN_d);
    not(i_111, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_112, i_113);
    and(i_112, SE_d, SI_d);
    and(i_113, i_114, D_d);
    not(i_114, SE_d);

    // Delayed data/reference logic
    and(id_63, SN_d, RN_d);
    and(id_64, id_63, i_119);
    not(i_119, SE_d);
    and(id_65, id_63, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_63, id_63, 1'b1);
      ng_xbuf(xid_64, id_64, 1'b1);
      ng_xbuf(xid_65, id_65, 1'b1);
    `endif
  `else
    //\seq_DFCPSX2_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_107, i_108);
    not(i_107, IQ);
    not(i_108, i_109);
    and(i_109, i_110, i_111);
    not(i_110, SN);
    not(i_111, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_112, i_113);
    and(i_112, SE, SI);
    and(i_113, i_114, D);
    not(i_114, SE);

    // Delayed data/reference logic
    and(id_60, SN, RN);
    and(id_61, id_60, i_118);
    not(i_118, SE);
    and(id_62, id_60, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_60, id_60, 1'b1);
      ng_xbuf(xid_61, id_61, 1'b1);
      ng_xbuf(xid_62, id_62, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_64), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_64), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_65), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_65), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_63), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_63), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_61), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_61), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_62), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_62), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_60), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_60), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX3_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX3_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPSX3_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_110, i_111);
    not(i_110, IQ);
    not(i_111, i_112);
    and(i_112, i_113, i_114);
    not(i_113, SN_d);
    not(i_114, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_115, i_116);
    and(i_115, SE_d, SI_d);
    and(i_116, i_117, D_d);
    not(i_117, SE_d);

    // Delayed data/reference logic
    and(id_81, SN_d, RN_d);
    and(id_82, id_81, i_122);
    not(i_122, SE_d);
    and(id_83, id_81, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_81, id_81, 1'b1);
      ng_xbuf(xid_82, id_82, 1'b1);
      ng_xbuf(xid_83, id_83, 1'b1);
    `endif
  `else
    //\seq_DFCPSX3_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_110, i_111);
    not(i_110, IQ);
    not(i_111, i_112);
    and(i_112, i_113, i_114);
    not(i_113, SN);
    not(i_114, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_115, i_116);
    and(i_115, SE, SI);
    and(i_116, i_117, D);
    not(i_117, SE);

    // Delayed data/reference logic
    and(id_78, SN, RN);
    and(id_79, id_78, i_121);
    not(i_121, SE);
    and(id_80, id_78, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_78, id_78, 1'b1);
      ng_xbuf(xid_79, id_79, 1'b1);
      ng_xbuf(xid_80, id_80, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_82), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_82), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_83), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_83), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_81), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_81), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_79), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_79), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_80), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_80), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_78), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_78), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX4_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX4_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPSX4_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_68, i_69);
    not(i_68, IQ);
    not(i_69, i_70);
    and(i_70, i_71, i_72);
    not(i_71, SN_d);
    not(i_72, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_73, i_74);
    and(i_73, SE_d, SI_d);
    and(i_74, i_75, D_d);
    not(i_75, SE_d);

    // Delayed data/reference logic
    and(id_45, SN_d, RN_d);
    and(id_46, id_45, i_80);
    not(i_80, SE_d);
    and(id_47, id_45, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_45, id_45, 1'b1);
      ng_xbuf(xid_46, id_46, 1'b1);
      ng_xbuf(xid_47, id_47, 1'b1);
    `endif
  `else
    //\seq_DFCPSX4_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_68, i_69);
    not(i_68, IQ);
    not(i_69, i_70);
    and(i_70, i_71, i_72);
    not(i_71, SN);
    not(i_72, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_73, i_74);
    and(i_73, SE, SI);
    and(i_74, i_75, D);
    not(i_75, SE);

    // Delayed data/reference logic
    and(id_42, SN, RN);
    and(id_43, id_42, i_79);
    not(i_79, SE);
    and(id_44, id_42, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_42, id_42, 1'b1);
      ng_xbuf(xid_43, id_43, 1'b1);
      ng_xbuf(xid_44, id_44, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_46), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_46), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_47), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_47), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX6_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX6_HV (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPSX6_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN_d);
    not(i_30, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE_d, SI_d);
    and(i_32, i_33, D_d);
    not(i_33, SE_d);

    // Delayed data/reference logic
    and(id_15, SN_d, RN_d);
    and(id_16, id_15, i_38);
    not(i_38, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    //\seq_DFCPSX6_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN);
    not(i_30, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE, SI);
    and(i_32, i_33, D);
    not(i_33, SE);

    // Delayed data/reference logic
    and(id_12, SN, RN);
    and(id_13, id_12, i_37);
    not(i_37, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX1_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX1_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPX1_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_49, i_50);
    not(i_49, IQ);
    not(i_50, i_51);
    and(i_51, i_52, i_53);
    not(i_52, SN_d);
    not(i_53, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_23, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    //\seq_DFCPX1_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_49, i_50);
    not(i_49, IQ);
    not(i_50, i_51);
    and(i_51, i_52, i_53);
    not(i_52, SN);
    not(i_53, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_22, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX2_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX2_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPX2_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_58, i_59);
    not(i_58, IQ);
    not(i_59, i_60);
    and(i_60, i_61, i_62);
    not(i_61, SN_d);
    not(i_62, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_47, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_47, id_47, 1'b1);
    `endif
  `else
    //\seq_DFCPX2_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_58, i_59);
    not(i_58, IQ);
    not(i_59, i_60);
    and(i_60, i_61, i_62);
    not(i_61, SN);
    not(i_62, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_46, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_46, id_46, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_47), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_47), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_47), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_47), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_46), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_46), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_46), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_46), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX3_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX3_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPX3_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_28, i_29);
    not(i_28, IQ);
    not(i_29, i_30);
    and(i_30, i_31, i_32);
    not(i_31, SN_d);
    not(i_32, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    //\seq_DFCPX3_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_28, i_29);
    not(i_28, IQ);
    not(i_29, i_30);
    and(i_30, i_31, i_32);
    not(i_31, SN);
    not(i_32, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX4_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX4_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPX4_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN_d);
    not(i_14, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_47, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_47, id_47, 1'b1);
    `endif
  `else
    //\seq_DFCPX4_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN);
    not(i_14, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_46, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_46, id_46, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_47), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_47), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_47), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_47), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_46), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_46), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_46), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_46), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX6_HV  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX6_HV (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    //\seq_DFCPX6_HV (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_34, i_35);
    not(i_34, IQ);
    not(i_35, i_36);
    and(i_36, i_37, i_38);
    not(i_37, SN_d);
    not(i_38, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_29, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    //\seq_DFCPX6_HV (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_34, i_35);
    not(i_34, IQ);
    not(i_35, i_36);
    and(i_36, i_37, i_38);
    not(i_37, SN);
    not(i_38, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_28, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_28, id_28, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_29), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_29), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_29), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_29), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_28), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_28), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX1_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX1_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCSX1_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_76, i_77);
    and(i_76, SE_d, SI_d);
    and(i_77, i_78, D_d);
    not(i_78, SE_d);

    // Delayed data/reference logic
    buf(id_57, RN_d);
    and(id_58, id_57, i_83);
    not(i_83, SE_d);
    and(id_59, id_57, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_57, id_57, 1'b1);
      ng_xbuf(xid_58, id_58, 1'b1);
      ng_xbuf(xid_59, id_59, 1'b1);
    `endif
  `else
    //\seq_DFCSX1_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_76, i_77);
    and(i_76, SE, SI);
    and(i_77, i_78, D);
    not(i_78, SE);

    // Delayed data/reference logic
    buf(id_54, RN);
    and(id_55, id_54, i_82);
    not(i_82, SE);
    and(id_56, id_54, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_54, id_54, 1'b1);
      ng_xbuf(xid_55, id_55, 1'b1);
      ng_xbuf(xid_56, id_56, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_58), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_58), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_59), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_59), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_57), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_57), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_55), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_55), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_56), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_56), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_54), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_54), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX2_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX2_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCSX2_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE_d, SI_d);
    and(i_41, i_42, D_d);
    not(i_42, SE_d);

    // Delayed data/reference logic
    buf(id_39, RN_d);
    and(id_40, id_39, i_47);
    not(i_47, SE_d);
    and(id_41, id_39, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_39, id_39, 1'b1);
      ng_xbuf(xid_40, id_40, 1'b1);
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    //\seq_DFCSX2_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE, SI);
    and(i_41, i_42, D);
    not(i_42, SE);

    // Delayed data/reference logic
    buf(id_36, RN);
    and(id_37, id_36, i_46);
    not(i_46, SE);
    and(id_38, id_36, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_36, id_36, 1'b1);
      ng_xbuf(xid_37, id_37, 1'b1);
      ng_xbuf(xid_38, id_38, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_41), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_41), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX3_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX3_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCSX3_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_21, RN_d);
    and(id_22, id_21, i_23);
    not(i_23, SE_d);
    and(id_23, id_21, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_21, id_21, 1'b1);
      ng_xbuf(xid_22, id_22, 1'b1);
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    //\seq_DFCSX3_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_18, RN);
    and(id_19, id_18, i_22);
    not(i_22, SE);
    and(id_20, id_18, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_18, id_18, 1'b1);
      ng_xbuf(xid_19, id_19, 1'b1);
      ng_xbuf(xid_20, id_20, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_23), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX4_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX4_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCSX4_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE_d, SI_d);
    and(i_41, i_42, D_d);
    not(i_42, SE_d);

    // Delayed data/reference logic
    buf(id_53, RN_d);
    and(id_54, id_53, i_47);
    not(i_47, SE_d);
    and(id_55, id_53, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_53, id_53, 1'b1);
      ng_xbuf(xid_54, id_54, 1'b1);
      ng_xbuf(xid_55, id_55, 1'b1);
    `endif
  `else
    //\seq_DFCSX4_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_40, i_41);
    and(i_40, SE, SI);
    and(i_41, i_42, D);
    not(i_42, SE);

    // Delayed data/reference logic
    buf(id_50, RN);
    and(id_51, id_50, i_46);
    not(i_46, SE);
    and(id_52, id_50, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_50, id_50, 1'b1);
      ng_xbuf(xid_51, id_51, 1'b1);
      ng_xbuf(xid_52, id_52, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_54), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_54), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_55), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_55), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_51), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_51), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_50), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_50), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX6_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX6_HV (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end
initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCSX6_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_52, i_53);
    and(i_52, SE_d, SI_d);
    and(i_53, i_54, D_d);
    not(i_54, SE_d);

    // Delayed data/reference logic
    buf(id_39, RN_d);
    and(id_40, id_39, i_59);
    not(i_59, SE_d);
    and(id_41, id_39, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_39, id_39, 1'b1);
      ng_xbuf(xid_40, id_40, 1'b1);
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    //\seq_DFCSX6_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_52, i_53);
    and(i_52, SE, SI);
    and(i_53, i_54, D);
    not(i_54, SE);

    // Delayed data/reference logic
    buf(id_36, RN);
    and(id_37, id_36, i_58);
    not(i_58, SE);
    and(id_38, id_36, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_36, id_36, 1'b1);
      ng_xbuf(xid_37, id_37, 1'b1);
      ng_xbuf(xid_38, id_38, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_41), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_41), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX1_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX1_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCX1_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    //\seq_DFCX1_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX2_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX2_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCX2_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_65, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_65, id_65, 1'b1);
    `endif
  `else
    //\seq_DFCX2_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_64, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_64, id_64, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_65), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_65), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_65), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_65), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_64), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_64), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_64), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_64), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX3_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX3_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCX3_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_61, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_61, id_61, 1'b1);
    `endif
  `else
    //\seq_DFCX3_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_60, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_60, id_60, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_61), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_61), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_61), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_61), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_60), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_60), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_60), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_60), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX4_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX4_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCX4_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_53, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_53, id_53, 1'b1);
    `endif
  `else
    //\seq_DFCX4_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_52, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_52, id_52, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_53), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_53), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_52), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_52), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX6_HV  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX6_HV (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge RN)  begin//IVAN
	if(~RN) #0 IQ  = 1'b0;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    //\seq_DFCX6_HV (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_29, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    //\seq_DFCX6_HV (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_28, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_28, id_28, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_29), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_29), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_29), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_29), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_28), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_28), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX1_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX1_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin
    if(!SN) IQ  <= 1;
    else    IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPSX1_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    //\seq_DFPSX1_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX2_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX2_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin
    if(!SN) IQ  <= 1;
    else    IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPSX2_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_35, SN_d);
    and(id_36, id_35, i_23);
    not(i_23, SE_d);
    and(id_37, id_35, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_35, id_35, 1'b1);
      ng_xbuf(xid_36, id_36, 1'b1);
      ng_xbuf(xid_37, id_37, 1'b1);
    `endif
  `else
    //\seq_DFPSX2_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_32, SN);
    and(id_33, id_32, i_22);
    not(i_22, SE);
    and(id_34, id_32, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_32, id_32, 1'b1);
      ng_xbuf(xid_33, id_33, 1'b1);
      ng_xbuf(xid_34, id_34, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_36), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_36), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_37), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_37), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_35), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_35), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_33), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_33), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_34), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_34), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_32), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_32), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX3_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX3_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin
    if(!SN) IQ  <= 1;
    else    IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPSX3_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_21, SN_d);
    and(id_22, id_21, i_23);
    not(i_23, SE_d);
    and(id_23, id_21, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_21, id_21, 1'b1);
      ng_xbuf(xid_22, id_22, 1'b1);
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    //\seq_DFPSX3_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_18, SN);
    and(id_19, id_18, i_22);
    not(i_22, SE);
    and(id_20, id_18, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_18, id_18, 1'b1);
      ng_xbuf(xid_19, id_19, 1'b1);
      ng_xbuf(xid_20, id_20, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_23), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX4_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX4_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin
    if(!SN) IQ  <= 1;
    else    IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPSX4_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    //\seq_DFPSX4_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX6_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX6_HV (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin
    if(!SN) IQ  <= 1;
    else    IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPSX6_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    //\seq_DFPSX6_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX1_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX1_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin//IVAN
	if(~SN) IQ  <= 1'b1;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPX1_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    //\seq_DFPX1_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX2_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX2_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin//IVAN
	if(~SN) IQ  <= 1'b1;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPX2_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    //\seq_DFPX2_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX3_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX3_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin//IVAN
	if(~SN) IQ  <= 1'b1;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPX3_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    //\seq_DFPX3_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX4_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX4_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin//IVAN
	if(~SN) IQ  <= 1'b1;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPX4_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    //\seq_DFPX4_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX6_HV  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX6_HV (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP or negedge SN)  begin//IVAN
	if(~SN) IQ  <= 1'b1;       
	else IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end




  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    //\seq_DFPX6_HV (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    //\seq_DFPX6_HV (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX1_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX1_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end







  `ifdef NTC
    //\seq_DFSX1_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_30, i_31);
    and(i_30, SE_d, SI_d);
    and(i_31, i_32, D_d);
    not(i_32, SE_d);

    // Delayed data/reference logic
    not(id_22, SE_d);
    buf(id_23, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    //\seq_DFSX1_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_30, i_31);
    and(i_30, SE, SI);
    and(i_31, i_32, D);
    not(i_32, SE);

    // Delayed data/reference logic
    not(id_20, SE);
    buf(id_21, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_20, id_20, 1'b1);
      ng_xbuf(xid_21, id_21, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_23), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_20), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_21), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_21), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX2_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX2_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFSX2_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_36, i_37);
    and(i_36, SE_d, SI_d);
    and(i_37, i_38, D_d);
    not(i_38, SE_d);

    // Delayed data/reference logic
    not(id_28, SE_d);
    buf(id_29, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_28, id_28, 1'b1);
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    //\seq_DFSX2_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_36, i_37);
    and(i_36, SE, SI);
    and(i_37, i_38, D);
    not(i_38, SE);

    // Delayed data/reference logic
    not(id_26, SE);
    buf(id_27, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_26, id_26, 1'b1);
      ng_xbuf(xid_27, id_27, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_29), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_29), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_26), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_26), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_27), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_27), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX3_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX3_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFSX3_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    //\seq_DFSX3_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX4_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX4_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFSX4_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    //\seq_DFSX4_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX6_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX6_HV (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFSX6_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    //\seq_DFSX6_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule
/*
primitive \seq_DFXL_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

    always @ (posedge CP)  begin
IQ  <= nextstate;
    end



endprimitive
*/


module DFXL_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end



  `ifdef NTC
    //\seq_DFXL_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    //\seq_DFXL_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif




  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX1_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX1_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFX1_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    //\seq_DFX1_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX2_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX2_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin

#1 IQ <=  1'b0;

end

  `ifdef NTC
    //\seq_DFX2_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    //\seq_DFX2_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX3_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX3_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFX3_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    //\seq_DFX3_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX4_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX4_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFX4_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    //\seq_DFX4_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX6_HV  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX6_HV (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge CP)  begin
            IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    //\seq_DFX6_HV (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    //\seq_DFX6_HV (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

module DLY1X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY2X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY3X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY4X1_HV (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module FAX1_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_360, i_363);
  or(i_360, i_361, i_362);
  and(i_361, A, B);
  and(i_362, A, CI);
  and(i_363, B, CI);
  not(SUM, i_368);
  or(i_368, i_369, i_375);
  and(i_369, i_370, CI);
  not(i_370, i_371);
  or(i_371, i_372, i_373);
  and(i_372, A, B);
  not(i_373, i_374);
  or(i_374, A, B);
  not(i_375, i_376);
  or(i_376, i_377, CI);
  not(i_377, i_378);
  or(i_378, i_379, i_380);
  and(i_379, A, B);
  not(i_380, i_381);
  or(i_381, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX2_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_72, i_75);
  or(i_72, i_73, i_74);
  and(i_73, A, B);
  and(i_74, A, CI);
  and(i_75, B, CI);
  not(SUM, i_80);
  or(i_80, i_81, i_87);
  and(i_81, i_82, CI);
  not(i_82, i_83);
  or(i_83, i_84, i_85);
  and(i_84, A, B);
  not(i_85, i_86);
  or(i_86, A, B);
  not(i_87, i_88);
  or(i_88, i_89, CI);
  not(i_89, i_90);
  or(i_90, i_91, i_92);
  and(i_91, A, B);
  not(i_92, i_93);
  or(i_93, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX3_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_336, i_339);
  or(i_336, i_337, i_338);
  and(i_337, A, B);
  and(i_338, A, CI);
  and(i_339, B, CI);
  not(SUM, i_344);
  or(i_344, i_345, i_351);
  and(i_345, i_346, CI);
  not(i_346, i_347);
  or(i_347, i_348, i_349);
  and(i_348, A, B);
  not(i_349, i_350);
  or(i_350, A, B);
  not(i_351, i_352);
  or(i_352, i_353, CI);
  not(i_353, i_354);
  or(i_354, i_355, i_356);
  and(i_355, A, B);
  not(i_356, i_357);
  or(i_357, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX4_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_360, i_363);
  or(i_360, i_361, i_362);
  and(i_361, A, B);
  and(i_362, A, CI);
  and(i_363, B, CI);
  not(SUM, i_368);
  or(i_368, i_369, i_375);
  and(i_369, i_370, CI);
  not(i_370, i_371);
  or(i_371, i_372, i_373);
  and(i_372, A, B);
  not(i_373, i_374);
  or(i_374, A, B);
  not(i_375, i_376);
  or(i_376, i_377, CI);
  not(i_377, i_378);
  or(i_378, i_379, i_380);
  and(i_379, A, B);
  not(i_380, i_381);
  or(i_381, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX6_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_321, i_324);
  or(i_321, i_322, i_323);
  and(i_322, A, B);
  and(i_323, A, CI);
  and(i_324, B, CI);
  not(SUM, i_329);
  or(i_329, i_330, i_336);
  and(i_330, i_331, CI);
  not(i_331, i_332);
  or(i_332, i_333, i_334);
  and(i_333, A, B);
  not(i_334, i_335);
  or(i_335, A, B);
  not(i_336, i_337);
  or(i_337, i_338, CI);
  not(i_338, i_339);
  or(i_339, i_340, i_341);
  and(i_340, A, B);
  not(i_341, i_342);
  or(i_342, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX8_HV (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_174, i_177);
  or(i_174, i_175, i_176);
  and(i_175, A, B);
  and(i_176, A, CI);
  and(i_177, B, CI);
  not(SUM, i_182);
  or(i_182, i_183, i_189);
  and(i_183, i_184, CI);
  not(i_184, i_185);
  or(i_185, i_186, i_187);
  and(i_186, A, B);
  not(i_187, i_188);
  or(i_188, A, B);
  not(i_189, i_190);
  or(i_190, i_191, CI);
  not(i_191, i_192);
  or(i_192, i_193, i_194);
  and(i_193, A, B);
  not(i_194, i_195);
  or(i_195, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FILLCELLX1_HV ();

endmodule

module FILLCELLX2_HV ();

endmodule

module FILLCELLX4_HV ();

endmodule

module FILLCELLX8_HV ();

endmodule

module FILLCELLX16_HV ();

endmodule

module FILLCELLX32_HV ();

endmodule

module HAX1_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_352);
  or(i_352, i_353, i_354);
  and(i_353, A, B);
  not(i_354, i_355);
  or(i_355, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX2_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_412);
  or(i_412, i_413, i_414);
  and(i_413, A, B);
  not(i_414, i_415);
  or(i_415, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX3_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_370);
  or(i_370, i_371, i_372);
  and(i_371, A, B);
  not(i_372, i_373);
  or(i_373, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX4_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_145);
  or(i_145, i_146, i_147);
  and(i_146, A, B);
  not(i_147, i_148);
  or(i_148, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX6_HV (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_340);
  or(i_340, i_341, i_342);
  and(i_341, A, B);
  not(i_342, i_343);
  or(i_343, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_251);
  or(i_251, i_252, i_255);
  or(i_252, i_253, i_254);
  and(i_253, B, A);
  and(i_254, C, B);
  and(i_255, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_320);
  or(i_320, i_321, i_324);
  or(i_321, i_322, i_323);
  and(i_322, B, A);
  and(i_323, C, B);
  and(i_324, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_360);
  or(i_360, i_361, i_364);
  or(i_361, i_362, i_363);
  and(i_362, B, A);
  and(i_363, C, B);
  and(i_364, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_386);
  or(i_386, i_387, i_390);
  or(i_387, i_388, i_389);
  and(i_388, B, A);
  and(i_389, C, B);
  and(i_390, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2XL_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_223);
  or(i_223, i_224, i_226);
  and(i_224, A, i_225);
  not(i_225, S);
  and(i_226, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X1_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_403);
  or(i_403, i_404, i_406);
  and(i_404, A, i_405);
  not(i_405, S);
  and(i_406, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X2_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_292);
  or(i_292, i_293, i_295);
  and(i_293, A, i_294);
  not(i_294, S);
  and(i_295, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X3_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_280);
  or(i_280, i_281, i_283);
  and(i_281, A, i_282);
  not(i_282, S);
  and(i_283, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X4_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_304);
  or(i_304, i_305, i_307);
  and(i_305, A, i_306);
  not(i_306, S);
  and(i_307, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X6_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_145);
  or(i_145, i_146, i_148);
  and(i_146, A, i_147);
  not(i_147, S);
  and(i_148, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X8_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_298);
  or(i_298, i_299, i_301);
  and(i_299, A, i_300);
  not(i_300, S);
  and(i_301, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X1_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_124);
  or(i_124, i_125, i_133);
  or(i_125, i_126, i_130);
  and(i_126, i_127, i_129);
  and(i_127, A, i_128);
  not(i_128, S1);
  not(i_129, S0);
  and(i_130, i_131, S0);
  and(i_131, B, i_132);
  not(i_132, S1);
  and(i_133, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X2_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_142);
  or(i_142, i_143, i_151);
  or(i_143, i_144, i_148);
  and(i_144, i_145, i_147);
  and(i_145, A, i_146);
  not(i_146, S1);
  not(i_147, S0);
  and(i_148, i_149, S0);
  and(i_149, B, i_150);
  not(i_150, S1);
  and(i_151, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X3_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_79);
  or(i_79, i_80, i_88);
  or(i_80, i_81, i_85);
  and(i_81, i_82, i_84);
  and(i_82, A, i_83);
  not(i_83, S1);
  not(i_84, S0);
  and(i_85, i_86, S0);
  and(i_86, B, i_87);
  not(i_87, S1);
  and(i_88, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X4_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_58);
  or(i_58, i_59, i_67);
  or(i_59, i_60, i_64);
  and(i_60, i_61, i_63);
  and(i_61, A, i_62);
  not(i_62, S1);
  not(i_63, S0);
  and(i_64, i_65, S0);
  and(i_65, B, i_66);
  not(i_66, S1);
  and(i_67, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X6_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_187);
  or(i_187, i_188, i_196);
  or(i_188, i_189, i_193);
  and(i_189, i_190, i_192);
  and(i_190, A, i_191);
  not(i_191, S1);
  not(i_192, S0);
  and(i_193, i_194, S0);
  and(i_194, B, i_195);
  not(i_195, S1);
  and(i_196, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X8_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_40);
  or(i_40, i_41, i_49);
  or(i_41, i_42, i_46);
  and(i_42, i_43, i_45);
  and(i_43, A, i_44);
  not(i_44, S1);
  not(i_45, S0);
  and(i_46, i_47, S0);
  and(i_47, B, i_48);
  not(i_48, S1);
  and(i_49, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X1_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X2_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_180);
  or(i_180, i_181, i_192);
  or(i_181, i_182, i_190);
  or(i_182, i_183, i_187);
  and(i_183, i_184, i_186);
  and(i_184, A, i_185);
  not(i_185, S1);
  not(i_186, S0);
  and(i_187, i_188, S0);
  and(i_188, B, i_189);
  not(i_189, S1);
  and(i_190, i_191, S0);
  and(i_191, D, S1);
  and(i_192, i_193, i_194);
  and(i_193, C, S1);
  not(i_194, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X3_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X4_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_84);
  or(i_84, i_85, i_96);
  or(i_85, i_86, i_94);
  or(i_86, i_87, i_91);
  and(i_87, i_88, i_90);
  and(i_88, A, i_89);
  not(i_89, S1);
  not(i_90, S0);
  and(i_91, i_92, S0);
  and(i_92, B, i_93);
  not(i_93, S1);
  and(i_94, i_95, S0);
  and(i_95, D, S1);
  and(i_96, i_97, i_98);
  and(i_97, C, S1);
  not(i_98, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X6_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_114);
  or(i_114, i_115, i_126);
  or(i_115, i_116, i_124);
  or(i_116, i_117, i_121);
  and(i_117, i_118, i_120);
  and(i_118, A, i_119);
  not(i_119, S1);
  not(i_120, S0);
  and(i_121, i_122, S0);
  and(i_122, B, i_123);
  not(i_123, S1);
  and(i_124, i_125, S0);
  and(i_125, D, S1);
  and(i_126, i_127, i_128);
  and(i_127, C, S1);
  not(i_128, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X8_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVXL_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX1_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX2_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX3_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX4_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX6_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX8_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX12_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX16_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX24_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX32_HV (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

primitive \seq_LGNX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           1           0           ?       : ? :           0;
           1           1           ?       : ? :           1;
           0           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGNX1_HV (CLK, E, GCK);
  input CLK;
  input E;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGNX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK_d, i_30);
    and(i_30, i_31, i_32);
    not(i_31, CLK_d);
    not(i_32, ENL);
    buf(nextstate, E_d);

  `else
    \seq_LGNX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK, i_30);
    and(i_30, i_31, i_32);
    not(i_31, CLK);
    not(i_32, ENL);
    buf(nextstate, E);

  `endif

  specify
    if((E == 1'b0)) (posedge CLK => (GCK +: 1'b1)) = (0.0, 0.0);
    if((E == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGPX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           0           0           ?       : ? :           0;
           0           1           ?       : ? :           1;
           1           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGPX1_HV (CLK, E, GCK);
  input CLK;
  input E;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGPX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK_d, ENL);
    buf(nextstate, E_d);

  `else
    \seq_LGPX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK, ENL);
    buf(nextstate, E);

  `endif

  specify
    if((E == 1'b0)) (negedge CLK => (GCK +: 1'b0)) = (0.0, 0.0);
    if((E == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGSNX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           1           0           ?       : ? :           0;
           1           1           ?       : ? :           1;
           0           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGSNX1_HV (CLK, E, SE, GCK);
  input CLK;
  input E;
  input SE;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGSNX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK_d, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK_d);
    not(i_14, ENL);
    or(nextstate, E_d, SE_d);

  `else
    \seq_LGSNX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK);
    not(i_14, ENL);
    or(nextstate, E, SE);

  `endif

  specify
    if((E == 1'b0) && (SE == 1'b0)) (posedge CLK => (GCK +: 1'b1)) = (0.0, 0.0);
    if((E == 1'b0) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b0)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, negedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, posedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGSPX1_HV  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           0           0           ?       : ? :           0;
           0           1           ?       : ? :           1;
           1           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGSPX1_HV (CLK, E, SE, GCK);
  input CLK;
  input E;
  input SE;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGSPX1_HV (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK_d, ENL);
    or(nextstate, E_d, SE_d);

  `else
    \seq_LGSPX1_HV (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK, ENL);
    or(nextstate, E, SE);

  `endif

  specify
    if((E == 1'b0) && (SE == 1'b0)) (negedge CLK => (GCK +: 1'b0)) = (0.0, 0.0);
    if((E == 1'b0) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b0)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, negedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, posedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX1_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX1_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX1_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX1_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX2_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX2_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX2_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX2_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX3_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX3_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX3_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX3_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX4_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX4_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX4_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX4_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX6_HV  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX6_HV (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX6_HV (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX6_HV (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX1_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX1_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX1_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX1_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX2_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX2_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX2_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX2_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX3_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX3_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX3_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX3_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX4_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX4_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX4_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX4_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX6_HV  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX6_HV (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX6_HV (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX6_HV (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX1_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX1_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX1_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX1_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX2_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX2_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX2_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX2_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX3_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX3_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX3_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX3_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX4_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX4_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX4_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX4_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX6_HV  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX6_HV (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX6_HV (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LHPX6_HV (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX1_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX1_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LHX1_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX1_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX2_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX2_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LHX2_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX2_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX3_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX3_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LHX3_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX3_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX4_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX4_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LHX4_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX4_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX6_HV  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX6_HV (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (posedge E)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LHX6_HV (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX6_HV (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX1_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX1_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX1_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX1_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX2_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX2_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX2_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_11, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNCPX2_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_10, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX3_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX3_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX3_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX3_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX4_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX4_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX4_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LNCPX4_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX6_HV  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX6_HV (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX6_HV (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX6_HV (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX1_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX1_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX1_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNCX1_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX2_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX2_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX2_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_LNCX2_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_23), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_22), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX3_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX3_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX3_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCX3_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX4_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX4_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX4_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_29, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    \seq_LNCX4_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_28, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_28, id_28, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_29), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_29), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_29), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_28), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX6_HV  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX6_HV (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX6_HV (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_17, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LNCX6_HV (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_16, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX1_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX1_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX1_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_7, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_7, id_7, 1'b1);
    `endif
  `else
    \seq_LNPX1_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_6, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_6, id_6, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_7), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_7), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_7), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_6), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_6), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_6), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX2_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX2_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX2_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_41, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    \seq_LNPX2_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_40, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_40, id_40, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_41), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_41), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_41), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_40), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX3_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX3_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX3_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_35, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_35, id_35, 1'b1);
    `endif
  `else
    \seq_LNPX3_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_34, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_34, id_34, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_35), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_35), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_35), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_34), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_34), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_34), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX4_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX4_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX4_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_13, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_13, id_13, 1'b1);
    `endif
  `else
    \seq_LNPX4_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_12, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_13), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_12), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_12), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX6_HV  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX6_HV (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX6_HV (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNPX6_HV (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX1_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX1_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LNX1_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX1_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX2_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX2_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LNX2_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX2_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX3_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX3_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LNX3_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX3_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX4_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX4_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LNX4_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX4_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX6_HV  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX6_HV (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;


  reg IQ;
  wire nextstate;


    always @ (negedge EN)  begin
IQ  <= nextstate;
    end

initial begin


#0 IQ  = 1'b0;

end

  `ifdef NTC
    \seq_LNX6_HV (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX6_HV (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

module MAJ3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_241, i_244);
  or(i_241, i_242, i_243);
  and(i_242, B, A);
  and(i_243, C, B);
  and(i_244, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_400, i_403);
  or(i_400, i_401, i_402);
  and(i_401, B, A);
  and(i_402, C, B);
  and(i_403, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_136, i_139);
  or(i_136, i_137, i_138);
  and(i_137, B, A);
  and(i_138, C, B);
  and(i_139, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_382, i_385);
  or(i_382, i_383, i_384);
  and(i_383, B, A);
  and(i_384, C, B);
  and(i_385, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X1_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_96, i_98);
  and(i_96, A, i_97);
  not(i_97, S);
  and(i_98, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X2_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_258, i_260);
  and(i_258, A, i_259);
  not(i_259, S);
  and(i_260, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X3_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_334, i_336);
  and(i_334, A, i_335);
  not(i_335, S);
  and(i_336, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X4_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_459, i_461);
  and(i_459, A, i_460);
  not(i_460, S);
  and(i_461, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X6_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_210, i_212);
  and(i_210, A, i_211);
  not(i_211, S);
  and(i_212, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X8_HV (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_240, i_242);
  and(i_240, A, i_241);
  not(i_241, S);
  and(i_242, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X1_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_36, i_44);
  or(i_36, i_37, i_41);
  and(i_37, i_38, i_40);
  and(i_38, A, i_39);
  not(i_39, S1);
  not(i_40, S0);
  and(i_41, i_42, S0);
  and(i_42, B, i_43);
  not(i_43, S1);
  and(i_44, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X2_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_96, i_104);
  or(i_96, i_97, i_101);
  and(i_97, i_98, i_100);
  and(i_98, A, i_99);
  not(i_99, S1);
  not(i_100, S0);
  and(i_101, i_102, S0);
  and(i_102, B, i_103);
  not(i_103, S1);
  and(i_104, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X3_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_126, i_134);
  or(i_126, i_127, i_131);
  and(i_127, i_128, i_130);
  and(i_128, A, i_129);
  not(i_129, S1);
  not(i_130, S0);
  and(i_131, i_132, S0);
  and(i_132, B, i_133);
  not(i_133, S1);
  and(i_134, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X4_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_162, i_170);
  or(i_162, i_163, i_167);
  and(i_163, i_164, i_166);
  and(i_164, A, i_165);
  not(i_165, S1);
  not(i_166, S0);
  and(i_167, i_168, S0);
  and(i_168, B, i_169);
  not(i_169, S1);
  and(i_170, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X6_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_60, i_68);
  or(i_60, i_61, i_65);
  and(i_61, i_62, i_64);
  and(i_62, A, i_63);
  not(i_63, S1);
  not(i_64, S0);
  and(i_65, i_66, S0);
  and(i_66, B, i_67);
  not(i_67, S1);
  and(i_68, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X8_HV (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_106, i_114);
  or(i_106, i_107, i_111);
  and(i_107, i_108, i_110);
  and(i_108, A, i_109);
  not(i_109, S1);
  not(i_110, S0);
  and(i_111, i_112, S0);
  and(i_112, B, i_113);
  not(i_113, S1);
  and(i_114, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X1_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X2_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X3_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X4_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X6_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X8_HV (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2XL_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_175);
  and(i_175, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_322);
  and(i_322, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_298);
  and(i_298, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_424);
  and(i_424, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_166);
  and(i_166, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_412);
  and(i_412, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_274);
  and(i_274, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X12_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_295);
  and(i_295, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_284);
  and(i_284, i_285, C);
  and(i_285, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_272);
  and(i_272, i_273, C);
  and(i_273, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_338);
  and(i_338, i_339, C);
  and(i_339, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_383);
  and(i_383, i_384, C);
  and(i_384, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_380);
  and(i_380, i_381, C);
  and(i_381, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_182);
  and(i_182, i_183, C);
  and(i_183, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X12_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_248);
  and(i_248, i_249, C);
  and(i_249, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_78);
  and(i_78, i_79, D);
  and(i_79, i_80, C);
  and(i_80, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_180);
  and(i_180, i_181, D);
  and(i_181, i_182, C);
  and(i_182, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_90);
  and(i_90, i_91, D);
  and(i_91, i_92, C);
  and(i_92, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_72);
  and(i_72, i_73, D);
  and(i_73, i_74, C);
  and(i_74, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_117);
  and(i_117, i_118, D);
  and(i_118, i_119, C);
  and(i_119, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_237);
  and(i_237, i_238, D);
  and(i_238, i_239, C);
  and(i_239, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2XL_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_316);
  or(i_316, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_208);
  or(i_208, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_268);
  or(i_268, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_406);
  or(i_406, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_169);
  or(i_169, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_352);
  or(i_352, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_322);
  or(i_322, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X12_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_292);
  or(i_292, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_272);
  or(i_272, i_273, C);
  or(i_273, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_362);
  or(i_362, i_363, C);
  or(i_363, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_242);
  or(i_242, i_243, C);
  or(i_243, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_326);
  or(i_326, i_327, C);
  or(i_327, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_203);
  or(i_203, i_204, C);
  or(i_204, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_260);
  or(i_260, i_261, C);
  or(i_261, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X12_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_116);
  or(i_116, i_117, C);
  or(i_117, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_12);
  or(i_12, i_13, D);
  or(i_13, i_14, C);
  or(i_14, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_66);
  or(i_66, i_67, D);
  or(i_67, i_68, C);
  or(i_68, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_48);
  or(i_48, i_49, D);
  or(i_49, i_50, C);
  or(i_50, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_336);
  or(i_336, i_337, D);
  or(i_337, i_338, C);
  or(i_338, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_216);
  or(i_216, i_217, D);
  or(i_217, i_218, C);
  or(i_218, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_222);
  or(i_222, i_223, D);
  or(i_223, i_224, C);
  or(i_224, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_278);
  and(i_278, i_279, B1);
  or(i_279, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_371);
  and(i_371, i_372, B1);
  or(i_372, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_362);
  and(i_362, i_363, B1);
  or(i_363, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_284);
  and(i_284, i_285, B1);
  or(i_285, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_224);
  and(i_224, i_225, B1);
  or(i_225, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_80);
  and(i_80, i_81, B1);
  or(i_81, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_232);
  and(i_232, i_233, i_234);
  or(i_233, A1, A2);
  or(i_234, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_234);
  and(i_234, i_235, i_236);
  or(i_235, A1, A2);
  or(i_236, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_214);
  and(i_214, i_215, i_216);
  or(i_215, A1, A2);
  or(i_216, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_99);
  and(i_99, i_100, i_101);
  or(i_100, A1, A2);
  or(i_101, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_168);
  and(i_168, i_169, i_170);
  or(i_169, A1, A2);
  or(i_170, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_252);
  and(i_252, i_253, i_254);
  or(i_253, A1, A2);
  or(i_254, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_234);
  and(i_234, i_235, B1);
  or(i_235, i_236, A3);
  or(i_236, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_291);
  and(i_291, i_292, B1);
  or(i_292, i_293, A3);
  or(i_293, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_207);
  and(i_207, i_208, B1);
  or(i_208, i_209, A3);
  or(i_209, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_48);
  and(i_48, i_49, B1);
  or(i_49, i_50, A3);
  or(i_50, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_153);
  and(i_153, i_154, B1);
  or(i_154, i_155, A3);
  or(i_155, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_132);
  and(i_132, i_133, B1);
  or(i_133, i_134, A3);
  or(i_134, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_244);
  and(i_244, i_245, i_247);
  or(i_245, i_246, A3);
  or(i_246, A1, A2);
  or(i_247, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_79);
  and(i_79, i_80, i_82);
  or(i_80, i_81, A3);
  or(i_81, A1, A2);
  or(i_82, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_103);
  and(i_103, i_104, i_106);
  or(i_104, i_105, A3);
  or(i_105, A1, A2);
  or(i_106, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_94);
  and(i_94, i_95, i_97);
  or(i_95, i_96, A3);
  or(i_96, A1, A2);
  or(i_97, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_34);
  and(i_34, i_35, i_37);
  or(i_35, i_36, A3);
  or(i_36, A1, A2);
  or(i_37, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_52);
  and(i_52, i_53, i_55);
  or(i_53, i_54, A3);
  or(i_54, A1, A2);
  or(i_55, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_196);
  and(i_196, i_197, C1);
  and(i_197, i_198, B1);
  or(i_198, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_126);
  and(i_126, i_127, C1);
  and(i_127, i_128, B1);
  or(i_128, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_150);
  and(i_150, i_151, C1);
  and(i_151, i_152, B1);
  or(i_152, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_189);
  and(i_189, i_190, C1);
  and(i_190, i_191, B1);
  or(i_191, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_198);
  and(i_198, i_199, C1);
  and(i_199, i_200, B1);
  or(i_200, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_318);
  and(i_318, i_319, C1);
  and(i_319, i_320, B1);
  or(i_320, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_97);
  and(i_97, i_98, C1);
  and(i_98, i_99, i_100);
  or(i_99, A1, A2);
  or(i_100, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_148);
  and(i_148, i_149, C1);
  and(i_149, i_150, i_151);
  or(i_150, A1, A2);
  or(i_151, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_55);
  and(i_55, i_56, C1);
  and(i_56, i_57, i_58);
  or(i_57, A1, A2);
  or(i_58, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_118);
  and(i_118, i_119, C1);
  and(i_119, i_120, i_121);
  or(i_120, A1, A2);
  or(i_121, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_79);
  and(i_79, i_80, C1);
  and(i_80, i_81, i_82);
  or(i_81, A1, A2);
  or(i_82, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_70);
  and(i_70, i_71, C1);
  and(i_71, i_72, i_73);
  or(i_72, A1, A2);
  or(i_73, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X1_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_62);
  and(i_62, i_63, C1);
  and(i_63, i_64, B1);
  or(i_64, i_65, A3);
  or(i_65, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X2_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_124);
  and(i_124, i_125, C1);
  and(i_125, i_126, B1);
  or(i_126, i_127, A3);
  or(i_127, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X3_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_31);
  and(i_31, i_32, C1);
  and(i_32, i_33, B1);
  or(i_33, i_34, A3);
  or(i_34, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X4_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_130);
  and(i_130, i_131, C1);
  and(i_131, i_132, B1);
  or(i_132, i_133, A3);
  or(i_133, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X6_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, B1);
  or(i_18, i_19, A3);
  or(i_19, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X8_HV (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_139);
  and(i_139, i_140, C1);
  and(i_140, i_141, B1);
  or(i_141, i_142, A3);
  or(i_142, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X1_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_262, B1);
  or(i_262, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X2_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_127, B1);
  or(i_127, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X3_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_361, B1);
  or(i_361, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X4_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_256, B1);
  or(i_256, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X6_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_232, B1);
  or(i_232, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X8_HV (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_106, B1);
  or(i_106, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X1_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_218, i_219);
  or(i_218, A1, A2);
  or(i_219, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X2_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_56, i_57);
  or(i_56, A1, A2);
  or(i_57, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X3_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_32, i_33);
  or(i_32, A1, A2);
  or(i_33, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X4_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_62, i_63);
  or(i_62, A1, A2);
  or(i_63, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X6_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_137, i_138);
  or(i_137, A1, A2);
  or(i_138, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X8_HV (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_275, i_276);
  or(i_275, A1, A2);
  or(i_276, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X1_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_302, B1);
  or(i_302, i_303, A3);
  or(i_303, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X2_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_206, B1);
  or(i_206, i_207, A3);
  or(i_207, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X3_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_182, B1);
  or(i_182, i_183, A3);
  or(i_183, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X4_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_206, B1);
  or(i_206, i_207, A3);
  or(i_207, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X6_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_218, B1);
  or(i_218, i_219, A3);
  or(i_219, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X8_HV (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_263, B1);
  or(i_263, i_264, A3);
  or(i_264, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X1_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_40, i_42);
  or(i_40, i_41, A3);
  or(i_41, A1, A2);
  or(i_42, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X2_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_12, i_14);
  or(i_12, i_13, A3);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X3_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_30, i_32);
  or(i_30, i_31, A3);
  or(i_31, A1, A2);
  or(i_32, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X4_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_45, i_47);
  or(i_45, i_46, A3);
  or(i_46, A1, A2);
  or(i_47, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X6_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_102, i_104);
  or(i_102, i_103, A3);
  or(i_103, A1, A2);
  or(i_104, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X8_HV (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_12, i_14);
  or(i_12, i_13, A3);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X1_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_116, C1);
  and(i_116, i_117, B1);
  or(i_117, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X2_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_251, C1);
  and(i_251, i_252, B1);
  or(i_252, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X3_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_44, C1);
  and(i_44, i_45, B1);
  or(i_45, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X4_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_125, C1);
  and(i_125, i_126, B1);
  or(i_126, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X6_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_194, C1);
  and(i_194, i_195, B1);
  or(i_195, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X8_HV (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_50, C1);
  and(i_50, i_51, B1);
  or(i_51, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X1_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_96, C1);
  and(i_96, i_97, i_98);
  or(i_97, A1, A2);
  or(i_98, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X2_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_12, C1);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X3_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_75, C1);
  and(i_75, i_76, i_77);
  or(i_76, A1, A2);
  or(i_77, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X4_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_48, C1);
  and(i_48, i_49, i_50);
  or(i_49, A1, A2);
  or(i_50, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X6_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_12, C1);
  and(i_12, i_13, i_14);
  or(i_13, A1, A2);
  or(i_14, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X8_HV (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_222, C1);
  and(i_222, i_223, i_224);
  or(i_223, A1, A2);
  or(i_224, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_274, C);
  or(i_274, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_193, C);
  or(i_193, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_172, C);
  or(i_172, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_238, C);
  or(i_238, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_352, C);
  or(i_352, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_445, C);
  or(i_445, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module TIE0_HV (Q);
  output Q;

  buf(Q, 0);
endmodule

module TIE1_HV (Q);
  output Q;

  buf(Q, 1);
endmodule

module XNOR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_184);
  xor(i_184, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_289);
  xor(i_289, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_310);
  xor(i_310, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_127);
  xor(i_127, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_400);
  xor(i_400, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_262);
  xor(i_262, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_240);
  not(i_240, i_241);
  or(i_241, i_242, i_248);
  and(i_242, i_243, C);
  not(i_243, i_244);
  or(i_244, i_245, i_246);
  and(i_245, A, B);
  not(i_246, i_247);
  or(i_247, A, B);
  not(i_248, i_249);
  or(i_249, i_250, C);
  not(i_250, i_251);
  or(i_251, i_252, i_253);
  and(i_252, A, B);
  not(i_253, i_254);
  or(i_254, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_324);
  not(i_324, i_325);
  or(i_325, i_326, i_332);
  and(i_326, i_327, C);
  not(i_327, i_328);
  or(i_328, i_329, i_330);
  and(i_329, A, B);
  not(i_330, i_331);
  or(i_331, A, B);
  not(i_332, i_333);
  or(i_333, i_334, C);
  not(i_334, i_335);
  or(i_335, i_336, i_337);
  and(i_336, A, B);
  not(i_337, i_338);
  or(i_338, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_204);
  not(i_204, i_205);
  or(i_205, i_206, i_212);
  and(i_206, i_207, C);
  not(i_207, i_208);
  or(i_208, i_209, i_210);
  and(i_209, A, B);
  not(i_210, i_211);
  or(i_211, A, B);
  not(i_212, i_213);
  or(i_213, i_214, C);
  not(i_214, i_215);
  or(i_215, i_216, i_217);
  and(i_216, A, B);
  not(i_217, i_218);
  or(i_218, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_318);
  not(i_318, i_319);
  or(i_319, i_320, i_326);
  and(i_320, i_321, C);
  not(i_321, i_322);
  or(i_322, i_323, i_324);
  and(i_323, A, B);
  not(i_324, i_325);
  or(i_325, A, B);
  not(i_326, i_327);
  or(i_327, i_328, C);
  not(i_328, i_329);
  or(i_329, i_330, i_331);
  and(i_330, A, B);
  not(i_331, i_332);
  or(i_332, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_195);
  not(i_195, i_196);
  or(i_196, i_197, i_203);
  and(i_197, i_198, C);
  not(i_198, i_199);
  or(i_199, i_200, i_201);
  and(i_200, A, B);
  not(i_201, i_202);
  or(i_202, A, B);
  not(i_203, i_204);
  or(i_204, i_205, C);
  not(i_205, i_206);
  or(i_206, i_207, i_208);
  and(i_207, A, B);
  not(i_208, i_209);
  or(i_209, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_168);
  not(i_168, i_169);
  or(i_169, i_170, i_176);
  and(i_170, i_171, C);
  not(i_171, i_172);
  or(i_172, i_173, i_174);
  and(i_173, A, B);
  not(i_174, i_175);
  or(i_175, A, B);
  not(i_176, i_177);
  or(i_177, i_178, C);
  not(i_178, i_179);
  or(i_179, i_180, i_181);
  and(i_180, A, B);
  not(i_181, i_182);
  or(i_182, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4XL_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_171);
  xor(i_171, i_172, A);
  xor(i_172, i_173, B);
  xor(i_173, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_204);
  xor(i_204, i_205, A);
  xor(i_205, i_206, B);
  xor(i_206, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_216);
  xor(i_216, i_217, A);
  xor(i_217, i_218, B);
  xor(i_218, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_288);
  xor(i_288, i_289, A);
  xor(i_289, i_290, B);
  xor(i_290, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_108);
  xor(i_108, i_109, A);
  xor(i_109, i_110, B);
  xor(i_110, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_178);
  xor(i_178, i_179, A);
  xor(i_179, i_180, B);
  xor(i_180, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_237);
  xor(i_237, i_238, A);
  xor(i_238, i_239, B);
  xor(i_239, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2XL_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_388);
  or(i_388, i_389, i_390);
  and(i_389, A, B);
  not(i_390, i_391);
  or(i_391, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X1_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_412);
  or(i_412, i_413, i_414);
  and(i_413, A, B);
  not(i_414, i_415);
  or(i_415, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X2_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_238);
  or(i_238, i_239, i_240);
  and(i_239, A, B);
  not(i_240, i_241);
  or(i_241, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X3_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_427);
  or(i_427, i_428, i_429);
  and(i_428, A, B);
  not(i_429, i_430);
  or(i_430, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X4_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_280);
  or(i_280, i_281, i_282);
  and(i_281, A, B);
  not(i_282, i_283);
  or(i_283, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X6_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_277);
  or(i_277, i_278, i_279);
  and(i_278, A, B);
  not(i_279, i_280);
  or(i_280, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X8_HV (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_172);
  or(i_172, i_173, i_174);
  and(i_173, A, B);
  not(i_174, i_175);
  or(i_175, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3XL_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_413);
  or(i_413, i_414, i_420);
  and(i_414, i_415, C);
  not(i_415, i_416);
  or(i_416, i_417, i_418);
  and(i_417, A, B);
  not(i_418, i_419);
  or(i_419, A, B);
  not(i_420, i_421);
  or(i_421, i_422, C);
  not(i_422, i_423);
  or(i_423, i_424, i_425);
  and(i_424, A, B);
  not(i_425, i_426);
  or(i_426, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X1_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_230);
  or(i_230, i_231, i_237);
  and(i_231, i_232, C);
  not(i_232, i_233);
  or(i_233, i_234, i_235);
  and(i_234, A, B);
  not(i_235, i_236);
  or(i_236, A, B);
  not(i_237, i_238);
  or(i_238, i_239, C);
  not(i_239, i_240);
  or(i_240, i_241, i_242);
  and(i_241, A, B);
  not(i_242, i_243);
  or(i_243, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X2_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_242);
  or(i_242, i_243, i_249);
  and(i_243, i_244, C);
  not(i_244, i_245);
  or(i_245, i_246, i_247);
  and(i_246, A, B);
  not(i_247, i_248);
  or(i_248, A, B);
  not(i_249, i_250);
  or(i_250, i_251, C);
  not(i_251, i_252);
  or(i_252, i_253, i_254);
  and(i_253, A, B);
  not(i_254, i_255);
  or(i_255, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X3_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_152);
  or(i_152, i_153, i_159);
  and(i_153, i_154, C);
  not(i_154, i_155);
  or(i_155, i_156, i_157);
  and(i_156, A, B);
  not(i_157, i_158);
  or(i_158, A, B);
  not(i_159, i_160);
  or(i_160, i_161, C);
  not(i_161, i_162);
  or(i_162, i_163, i_164);
  and(i_163, A, B);
  not(i_164, i_165);
  or(i_165, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X4_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_140);
  or(i_140, i_141, i_147);
  and(i_141, i_142, C);
  not(i_142, i_143);
  or(i_143, i_144, i_145);
  and(i_144, A, B);
  not(i_145, i_146);
  or(i_146, A, B);
  not(i_147, i_148);
  or(i_148, i_149, C);
  not(i_149, i_150);
  or(i_150, i_151, i_152);
  and(i_151, A, B);
  not(i_152, i_153);
  or(i_153, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X6_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_294);
  or(i_294, i_295, i_301);
  and(i_295, i_296, C);
  not(i_296, i_297);
  or(i_297, i_298, i_299);
  and(i_298, A, B);
  not(i_299, i_300);
  or(i_300, A, B);
  not(i_301, i_302);
  or(i_302, i_303, C);
  not(i_303, i_304);
  or(i_304, i_305, i_306);
  and(i_305, A, B);
  not(i_306, i_307);
  or(i_307, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X8_HV (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_329);
  or(i_329, i_330, i_336);
  and(i_330, i_331, C);
  not(i_331, i_332);
  or(i_332, i_333, i_334);
  and(i_333, A, B);
  not(i_334, i_335);
  or(i_335, A, B);
  not(i_336, i_337);
  or(i_337, i_338, C);
  not(i_338, i_339);
  or(i_339, i_340, i_341);
  and(i_340, A, B);
  not(i_341, i_342);
  or(i_342, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4XL_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_83, A);
  xor(i_83, i_84, B);
  xor(i_84, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X1_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_104, A);
  xor(i_104, i_105, B);
  xor(i_105, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X2_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_113, A);
  xor(i_113, i_114, B);
  xor(i_114, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X3_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_155, A);
  xor(i_155, i_156, B);
  xor(i_156, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X4_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_221, A);
  xor(i_221, i_222, B);
  xor(i_222, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X6_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_8, A);
  xor(i_8, i_9, B);
  xor(i_9, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X8_HV (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_8, A);
  xor(i_8, i_9, B);
  xor(i_9, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module LOGIC0_HV (Q);
  output Q;

  buf(Q, 0);
endmodule

module LOGIC1_HV (Q);
  output Q;

  buf(Q, 1);
endmodule

module ANTENNA_HV (A);
  input A;

endmodule


`ifdef TETRAMAX
`else
  primitive ng_xbuf (o, i, d);
	output o;
	input i, d;
	table
	// i   d   : o
	   0   1   : 0 ;
	   1   1   : 1 ;
	   x   1   : 1 ;
	endtable
  endprimitive
`endif
//
// End of file
//
